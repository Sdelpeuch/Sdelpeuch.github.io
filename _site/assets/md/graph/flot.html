<!DOCTYPE HTML>
<!--
Prologue by HTML5 UP
html5up.net | @ajlkn
Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
Jekyll integration by Chris Bobbe | chrisbobbe.github.io
-->
<html><head><!-- Robots -->
  <meta name="robots" content="index, follow" /><link rel="canonical" href="http://localhost:4000/assets/md/graph/flot.html" /><!-- Title, description, author --><title>&lt;i class=&quot;fas fa-project-diagram fa-2x&quot;&gt;&lt;/i&gt; Graphe - Le problème du flot maximal | Informatique - ENSEIRB-Matmeca</title>
  <meta name="description" content="Cours d&#39;informatique du Semestre 6 de l&#39;ENSEIRB-MATEMCA, année 2019/2020" />
  <meta name="author" content="Delpeuch Sébastien" />
  
  <!-- Open Graph -->
  <meta property="og:title" content="&lt;i class=&quot;fas fa-project-diagram fa-2x&quot;&gt;&lt;/i&gt; Graphe - Le problème du flot maximal | Informatique - ENSEIRB-Matmeca" />
  <meta property="og:type" content="website" />
  <meta property="og:image" content="http://localhost:4000/assets/images/t%C3%A9l%C3%A9chargement.svg" />
  <meta property="og:url" content="http://localhost:4000/assets/md/graph/flot.html" />
  <meta property="og:site_name" content="Informatique" />
  <meta property="og:description" content="Cours d&#39;informatique du Semestre 6 de l&#39;ENSEIRB-MATEMCA, année 2019/2020" />
  
  <!-- Styles -->
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!--[if lte IE 8]><script src="/assets/js/ie/html5shiv.js" defer></script><![endif]-->
  <link rel="stylesheet" href="/assets/css/main.css" />
  <!--[if lte IE 8]><link rel="stylesheet" href="/assets/css/ie8.css" /><![endif]-->
  <!--[if lte IE 9]><link rel="stylesheet" href="/assets/css/ie9.css" /><![endif]-->
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/all.css">

  <!-- Scripts -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js" defer></script>
  <script src="/assets/js/jquery.scrolly.min.js" defer></script>
  <script src="/assets/js/jquery.scrollzer.min.js" defer></script>
  <script src="/assets/js/skel.min.js" defer></script>
  <script src="/assets/js/util.js" defer></script>
  <!--[if lte IE 8]><script src="/assets/js/ie/respond.min.js" defer></script><![endif]-->
  <script src="/assets/js/main.js" defer></script>

</head><body><!-- Header -->
<div id="header">
  <div class="top"><!-- Logo -->
<div id="logo">
  <a href="http://localhost:4000/" id="home-link">
    <span class="image avatar48"><img src="/assets/images/t%C3%A9l%C3%A9chargement.svg" alt="Avatar of Delpeuch Sébastien" /></span>
    <h1 id="title">Informatique</h1>
    <p>ENSEIRB-Matmeca</p>
  </a>
</div><!-- Nav -->
<nav id="nav">
  <ul><li><a href="http://localhost:4000/" id="semestre-6-en-cours-link">
            <span class="icon fa-link">Semestre 6 - En cours</span>
          </a></li><li><a href="http://localhost:4000/Semestre_5.html" id="semestre-5-link">
            <span class="icon fa-check">Semestre 5</span>
          </a></li></ul>
</nav></div>
  <div class="bottom"><!-- Social Icons -->
<ul class="icons"><li><a href="https://github.com/Sdelpeuch" class="icon-b fa-github"><span class="label">GitHub</span></a></li><li><a href="mailto:sebastien.delpeuch@enseirb-matmeca.fr" class="icon fa-envelope"><span class="label">Email</span></a></li></ul>
</div>
</div>
<!-- Main -->
<div id="main">
	<!-- Page -->
	<article class="shade-two">
	  <div class="container">
			<header>
				<h2><i class="fas fa-project-diagram fa-2x"></i> Graphe - Le problème du flot maximal</h2></header><script type="text/javascript" async="" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<p>Cours inspiré des cours intégrés dispensés par <a href="https://www.labri.fr/index.php?n=Annuaires.Profile&amp;id=Hanusse_ID1084917714">Nicolas
Hanusse</a>
et du
<a href="https://moodle.bordeaux-inp.fr/pluginfile.php/51350/mod_resource/content/1/cours-graphe.pdf">polycopié</a>
de <a href="https://www.labri.fr/index.php?n=Annuaires.Profile&amp;id=Lapoire_ID1084917727">Denis Lapoire</a></p>

<p>Un système dans lequel un matériau s’écoule, tel l’eau ou l’électricité, peut
être modélisé à l’aide d’un graphe. Une question anturelle se pose : quelle est
la capacité maximale de ce système ? Ce problème est connu sous le nom de flot
maximal et admet plusieurs solutions algorithmiques efficaces. Nous en
présenterons ici quelques unes.</p>

<h2 id="-définitions"><i class="fas fa-project-diagram"></i> Définitions</h2>

<p>Un <code class="language-plaintext highlighter-rouge">réseau</code> est un 5-uplet <script type="math/tex">G=(V,E,c,s,t)</script> noté <script type="math/tex">(V_G,E_G,c_G,s_G,t_G)</script> où</p>
<ul>
  <li><script type="math/tex">(V,E)</script> est un graphe simple orienté où <script type="math/tex">E</script> est supposé être <script type="math/tex">E=V \times
V</script></li>
  <li><script type="math/tex">e</script> associe à chaque arc <script type="math/tex">e</script> sa capacité, c’est à dire un réel positif ou
nul noté <script type="math/tex">c(e)</script></li>
  <li><script type="math/tex">s</script> est un sommet appelé la source</li>
  <li><script type="math/tex">t</script> est un sommet distinct de <script type="math/tex">s</script> appelé le puits</li>
</ul>

<p>Un flot de <script type="math/tex">G</script> est une fonction qui associe à chaque arc <script type="math/tex">(u,v) \in E</script> un
réel appelé le flot réel de <script type="math/tex">u</script> à <script type="math/tex">v</script> et tel que</p>
<ol>
  <li>contrainte de capacité : pour tout arc <script type="math/tex">(u,v) \in E</script>, on a <script type="math/tex">f(u,v)\leq
c(u,v)</script></li>
  <li>symétrie : pour tout arc <script type="math/tex">(u,v) \in E</script>, on a : <script type="math/tex">f(u,v)=-f(v,u)</script></li>
  <li>conservation du flot: tout sommet <script type="math/tex">u \in V - \{s,t\}</script> vérifie : <script type="math/tex">\sum
\limits_{v \in V} f(u,v)=0</script></li>
</ol>

<p>La valeur du flot <script type="math/tex">f</script>, notée <script type="math/tex">|f|</script> est la quantité <script type="math/tex">\sum \limits_{v \in V}
f(s,v)</script></p>

<p>Le problème du flot maximal consiste à calculer pour tout réseau un flot de
vlaeur maximale. Dans la suite de ce chapitre, nous noterons <em>flot net positif</em>
d’un sommet <script type="math/tex">u</script> la somme des flots nets positifs sortant de <script type="math/tex">u</script> c’est à dire
plus formellement <script type="math/tex">\sum \limits_{v \in V, f(u,v)>0} f(u,v)</script>. Afin d’établir la
correction des algorithmes résolvant le problème du flot maximal, nous
établissons ci dessous un lemme portant sur le flot entre deux ensembles de
sommets <script type="math/tex">X</script> et <script type="math/tex">Y</script>. Cette quantité définie pour tout couple d’ensembles de
sommets <script type="math/tex">X</script> et <script type="math/tex">Y</script> est noté <script type="math/tex">f(X,Y)</script> et est égale à</p>

<script type="math/tex; mode=display">f(X,Y)=\sum \limits_{x \in X}\sum \limits_{y \in Y}f(x,y)</script>

<h2 id="-propriétés"><i class="fas fa-project-diagram"></i> Propriétés</h2>

<h3 id="réseau-résiduel">Réseau résiduel</h3>
<p>LA propriété qui suit implique que tout flot de valeur non nulle est, si il n’est pas maximal, un début de réponse. En effet nous pouvons définir à partir de ce flot <script type="math/tex">f</script> défini sur un réseau <script type="math/tex">G</script> un nouveau réseau <script type="math/tex">G'</script> “plus simple” pour lequel tout flot maximal <script type="math/tex">f'</script> permettra de définir le flot maximal <script type="math/tex">f'+f</script> sur <script type="math/tex">G</script>.</p>

<h4 id="définition">Définition.</h4>

<p>La capacité résiduelle d’un réseau <script type="math/tex">(V,E,c,s,t)</script> induit par un flot <script type="math/tex">f</script> est la fonction notée <script type="math/tex">c_f</script> qui associe à tout arc <script type="math/tex">(u,v) \in E</script> le réel positif ou nul <script type="math/tex">c(u,v)-f(u,v)</script>. Le réseau résiduel d’un réseau <script type="math/tex">(V,E,c,s,t)</script> induit par un flot <script type="math/tex">f</script> est le réseau <script type="math/tex">(V,E,c_f,s,t)</script>.</p>

<h3 id="chemin-améliorant">Chemin améliorant</h3>

<p>Définir un flot peut se réaliser simplement en choisissant dans le réseau un chemin de <script type="math/tex">s</script> à <script type="math/tex">t</script> et en prenant pour valeur la capacité minimale des arcs de ce chemin.</p>

<h4 id="définition-1">Définition.</h4>

<p>Soit <script type="math/tex">G=(V,E,c,s,t)</script> un réseau et <script type="math/tex">p</script> un chemin élémentaire dans <script type="math/tex">G</script> de <script type="math/tex">s</script> à <script type="math/tex">t</script>. La capacité de <script type="math/tex">p</script> est le minimum des capacités des arcs que possède <script type="math/tex">p</script> et est noté <script type="math/tex">c(p)</script>. Le flot induit par <script type="math/tex">p</script> est la fonction notée <script type="math/tex">f_P</script> qui associe à tout arc <script type="math/tex">(u,v) \in V^2</script> la quantité définie par</p>
<ul>
  <li><script type="math/tex">c(p)</script> si <script type="math/tex">(u,v)</script> appartient à <script type="math/tex">p</script></li>
  <li><script type="math/tex">-c(p)</script> si <script type="math/tex">u,v</script> appartient à <script type="math/tex">p</script></li>
  <li><script type="math/tex">0</script> sinon</li>
</ul>

<p>Un chemin <script type="math/tex">p</script> allant de <script type="math/tex">s</script> à <script type="math/tex">t</script> améliore un flot <script type="math/tex">f</script> de <script type="math/tex">G</script> si la capacité de <script type="math/tex">p</script> dans le réseau résiduel de <script type="math/tex">G</script> induit par <script type="math/tex">f</script> est positive.</p>

<h4 id="lemme">Lemme.</h4>

<p>La fonction <script type="math/tex">f_P</script> induit par un chemin élémentaire <script type="math/tex">p</script> de la source au puits dans un réseau est un flot de valeur <script type="math/tex">c(p)</script>.</p>

<h2 id="-maxiflot--minicoupe"><i class="fas fa-project-diagram"></i> Maxiflot &amp; MiniCoupe</h2>
<p>Nous allons établir le théorème <code class="language-plaintext highlighter-rouge">minimax</code> qui caractérise un entier maximal à vérifier une certaine propriété comme étant minimal à en vérifier une seconde. Ce genre de résultat est à remarquer car il augure souvent favorablement la possibilité de calculer efficacement un tel entier.</p>

<h4 id="définition-2">Définition.</h4>

<p>Une <code class="language-plaintext highlighter-rouge">coupe</code> dans un réseau <script type="math/tex">G=(V,E,c,s,t)</script> est un couple d’ensembles de sommets de la forme <script type="math/tex">(X,V-X)</script> avec <script type="math/tex">X\subseteq V</script> tel que <script type="math/tex">s \in X</script> et <script type="math/tex">t \in Y</script>. Sa <code class="language-plaintext highlighter-rouge">capacité</code>, notéée <script type="math/tex">c(X,Y)</script>, est la somme <script type="math/tex">\sum \limits_{x \in X, y \in Y} c(x,y)</script>. Une coupe est minimale si sa capacité est au plus égale à la capacité de toute coupe de ce réseau. Le flot d’une coupe <script type="math/tex">(X,Y)</script> relativement à un flot <script type="math/tex">f</script> est la quantité <script type="math/tex">f(X,Y)</script>.</p>

<h4 id="lemme-1">Lemme.</h4>

<p>Tout flot <script type="math/tex">f</script> et toute coupe <script type="math/tex">(X,Y)</script> d’un même réseau de capacité <script type="math/tex">c</script> vérifient</p>

<script type="math/tex; mode=display">|f|=f(X,Y) \leq c(X,Y)</script>

<h4 id="théorème">Théorème.</h4>

<p>Soit <script type="math/tex">f</script> un flot dans un réseau <script type="math/tex">G</script>. Les quatre assertions suivantes sont équivalentes</p>
<ol>
  <li><script type="math/tex">f</script> est un flot maximal</li>
  <li><script type="math/tex">f</script> n’admet aucun chemin améliorant</li>
  <li>il existe une coupe dans le réseau résiduel induit par <script type="math/tex">f</script> de capacité nulle</li>
  <li>il existe une coupe <script type="math/tex">(X,Y)</script> de capacité <script type="math/tex">c_G(X,Y)</script> égale au flot <script type="math/tex">f(X,Y)</script></li>
</ol>

<h4 id="corollaire-maxiflot--minicoupe">Corollaire (MaxiFlot &amp; MiniCoupe)</h4>

<p>Pour tout réseau, la valeur maximale des flots est égale à la capacité minimale des coupes.</p>

<h2 id="-deux-solutions-au-problème-du-flot-maximal"><i class="fas fa-project-diagram"></i> Deux solutions au problème du flot maximal</h2>

<h3 id="ford-fulkerson">Ford Fulkerson</h3>
<p><img class="image about right" src="/assets/images/graphe/FordFulkerson.gif" alt="fordfulkerson" /> L’algorithme de Ford-Fulkerson est un algorithmes pour le problème du flot maximum. Il s’agit d’un algorithme itératif. A chaque itération, la solution courante est un flot qui satisfait les contraintes de capacité (c’est donc un flot réalisable) et l’algorithme essaie d’augmenter la valeur de ce flot. Considérons un flux possible dont les sous-ensembles sont les différents flux associés à chaque arête ou arc du graphe. A chaque itération de la boucle, deux sous-procédures viennent compléter le processus.</p>
<ul>
  <li>le marquage qui consiste à tester si une amélioration du flux est possible</li>
  <li>le changement de flux, soit la procédure qui donne la meilleure solution à partir de l’observation précédent</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fonction FordFulkerson(G=(V,E,c,s,t):réseau):flot
    fmax = 0
    tant qu'il existe un chemin de s à t de capacité positive faire
        calculer un chemmin p élémentaire de s à t de capacité positive 
        f = flotInduit(G,p)
        G = réseauRésiduel(G,f)
        fmax = fmax + f
        retourner fmax
</code></pre></div></div>

<p>Pour garantir une complexité polynomiale, le marquage doit être fait dans le même ordre que la découverte des commets. La complexité de l’algorithme est alors en <script type="math/tex">O(m^2 n)</script> pour un graphe avec <script type="math/tex">n</script> sommets et <script type="math/tex">m</script> arcs.</p>

<h3 id="une-amélioration-de-ford-fulkerson-qui-termine">Une amélioration de Ford Fulkerson qui termine</h3>

<p>Dans la définition de <code class="language-plaintext highlighter-rouge">FordFulkerson</code>, aucune précision n’a été indiquée sur la façon de calculer un chemin de <script type="math/tex">s</script> à <script type="math/tex">t</script> non nulle. Cette question est pourtant cruciale, sur des graphes à valeur réelles, l’algorithme ne se termine pas.</p>

<p>Cette grande faiblesse de <code class="language-plaintext highlighter-rouge">FordFulkerson</code> peut être facilement corrigée : en effet, si l’on utilise un simple parcours en largeur à partir de <script type="math/tex">s</script> pour calculer un plus court chemin de <script type="math/tex">s</script> à <script type="math/tex">t</script>, on obtient un algorithme qui termine et donc de bien meilleure complexité en temps dans le pire des cas</p>

<p><img class="image about center" src="/assets/images/graphe/edmond.gif" alt="edmondkarp" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fonction EdmondKarpsRec(G=(V,E,c,s,t):réseau):flot
    si il n'existe aucun chemin de s à t de capacité positive faire 
        retourner 0
    sinon 
        calculer un plus court chemin p de s à t de capacité positive
        f = flotInduit(G,p)
        H = réseauRésiduel(G,f)
        retourner f + EdmondKarpsRec(K)
</code></pre></div></div>

<p>Le temps d’exécution de <script type="math/tex">O(n m^2)</script> s’obtient en constatant que chaque chemin augmentant peut être trouvé en temps <script type="math/tex">O(m)</script>, qu’à chaque fois au moins un arc de <script type="math/tex">E</script> est saturé, que la distance de la source à un arc saturé par le chemin augmentant croît à chaque fois que l’arc est saturé, et que cette longueur est au pllus <script type="math/tex">V</script>. Une autre propriété de cet algorithme est que la longueur du plus court chemin augmentant croît .</p>

<h2 id="-théorèmes-de-menger"><i class="fas fa-project-diagram"></i> Théorèmes de Menger</h2>
<p>Nous conclurons ce chapitre en présentant les Théorèmes de Menger. Chacun de ces théorèmes établit pour tous sommets <script type="math/tex">s \neq t</script> l’égalité de deux entiers</p>
<ul>
  <li>le plus petit nombre d’objet qu’il faut retirer pour déconnecter <script type="math/tex">s</script> de <script type="math/tex">t</script></li>
  <li>le plus grand nombre de chemins objet disjoint connectant <script type="math/tex">s</script> à <script type="math/tex">t</script></li>
</ul>
</div>
	</article>
</div><!-- Footer -->
<div id="footer">
  
  <!-- Copyright -->
  <ul class="copyright">
    
      <li>&copy;Informatique. All rights reserved.</li>
    
    <li>Design: <a href="http://html5up.net">HTML5 UP</a></li>
    <li>Jekyll integration: <a href="https://chrisbobbe.github.io/">Chris Bobbe</a></li>
  </ul>
  
</div></body>
</html>