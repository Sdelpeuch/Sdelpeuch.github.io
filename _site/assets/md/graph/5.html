<!DOCTYPE HTML>
<!--
Prologue by HTML5 UP
html5up.net | @ajlkn
Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
Jekyll integration by Chris Bobbe | chrisbobbe.github.io
-->
<html><head><!-- Robots -->
  <meta name="robots" content="index, follow" /><link rel="canonical" href="http://localhost:4000/assets/md/graph/5.html" /><!-- Title, description, author --><title>&lt;i class=&quot;fas fa-project-diagram fa-2x&quot;&gt;&lt;/i&gt; Graphe - Cycle et voyageur de commerce | Informatique - ENSEIRB-Matmeca</title>
  <meta name="description" content="Cours d&#39;informatique du Semestre 6 de l&#39;ENSEIRB-MATEMCA, année 2019/2020" />
  <meta name="author" content="Delpeuch Sébastien" />
  
  <!-- Open Graph -->
  <meta property="og:title" content="&lt;i class=&quot;fas fa-project-diagram fa-2x&quot;&gt;&lt;/i&gt; Graphe - Cycle et voyageur de commerce | Informatique - ENSEIRB-Matmeca" />
  <meta property="og:type" content="website" />
  <meta property="og:image" content="http://localhost:4000/assets/images/t%C3%A9l%C3%A9chargement.svg" />
  <meta property="og:url" content="http://localhost:4000/assets/md/graph/5.html" />
  <meta property="og:site_name" content="Informatique" />
  <meta property="og:description" content="Cours d&#39;informatique du Semestre 6 de l&#39;ENSEIRB-MATEMCA, année 2019/2020" />
  
  <!-- Styles -->
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!--[if lte IE 8]><script src="/assets/js/ie/html5shiv.js" defer></script><![endif]-->
  <link rel="stylesheet" href="/assets/css/main.css" />
  <!--[if lte IE 8]><link rel="stylesheet" href="/assets/css/ie8.css" /><![endif]-->
  <!--[if lte IE 9]><link rel="stylesheet" href="/assets/css/ie9.css" /><![endif]-->
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/all.css">

  <!-- Scripts -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js" defer></script>
  <script src="/assets/js/jquery.scrolly.min.js" defer></script>
  <script src="/assets/js/jquery.scrollzer.min.js" defer></script>
  <script src="/assets/js/skel.min.js" defer></script>
  <script src="/assets/js/util.js" defer></script>
  <!--[if lte IE 8]><script src="/assets/js/ie/respond.min.js" defer></script><![endif]-->
  <script src="/assets/js/main.js" defer></script>

</head><body><!-- Header -->
<div id="header">
  <div class="top"><!-- Logo -->
<div id="logo">
  <a href="http://localhost:4000/" id="home-link">
    <span class="image avatar48"><img src="/assets/images/t%C3%A9l%C3%A9chargement.svg" alt="Avatar of Delpeuch Sébastien" /></span>
    <h1 id="title">Informatique</h1>
    <p>ENSEIRB-Matmeca</p>
  </a>
</div><!-- Nav -->
<nav id="nav">
  <ul><li><a href="http://localhost:4000/" id="semestre-6-en-cours-link">
            <span class="icon fa-link">Semestre 6 - En cours</span>
          </a></li><li><a href="http://localhost:4000/Semestre_5.html" id="semestre-5-link">
            <span class="icon fa-check">Semestre 5</span>
          </a></li></ul>
</nav></div>
  <div class="bottom"><!-- Social Icons -->
<ul class="icons"><li><a href="https://github.com/Sdelpeuch" class="icon-b fa-github"><span class="label">GitHub</span></a></li><li><a href="mailto:sebastien.delpeuch@enseirb-matmeca.fr" class="icon fa-envelope"><span class="label">Email</span></a></li></ul>
</div>
</div>
<!-- Main -->
<div id="main">
	<!-- Page -->
	<article class="shade-two">
	  <div class="container">
			<header>
				<h2><i class="fas fa-project-diagram fa-2x"></i> Graphe - Cycle et voyageur de commerce</h2></header><script type="text/javascript" async="" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<center>
<iframe src="/assets/pdf/voyageur.pdf" height="600" width="60%"></iframe>
</center>

<h2 id="exercice-1">Exercice 1</h2>

<ol>
  <li>Une première version naïve serait d’utiliser un algortihme de type brute
force. On part des <script type="math/tex">n</script> sommets et à chaque itération on appelle l’algorithme
sur les <script type="math/tex">n-1</script> arêtes possibles etc. Cela nous donne <script type="math/tex">n!</script> possibilités, soit
la pire complexité possible. Pour résoudre cet algorithme il faut un moyen de
générer les permutations, l’algorithme de heap itératif est utilisable.</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Pour la version itérative, on simule le processus récursif en mémorisant les indices de boucle dans un tableau compteur.
// compteur[k] représente, dans cette simulation, l'indice courant dans la boucle de Heap(k,A).

Heap_iteratif(n : entier, A : tableau) :
    
    compteur := tableau de n entiers, initialisés à 0

    écrire A
    
    // i indique le niveau de la boucle en cours d'incrémentation
    i := 0;

    Tant que i &lt; n :
        
        Si  compteur[i] &lt; i :
            Si i est pair :
                échanger A[0] et A[i]
            Sinon :
                échanger A[compteur[i]], A[i]
            Fin Si
            écrire A
            
            compteur[i] += 1 // on incrémente l'indice de boucle après avoir effectué une itération
            i := 0 // on retourne au cas de base de la version récursive
        
        Sinon :
            // la boucle de niveau i est terminée, on peut donc réinitialiser l'indice et retourner au niveau supérieur
            compteur[i] := 0
            i += 1
        
        Fin Si
    
    Fin Tant que
</code></pre></div></div>
<ol>
  <li>On peut appliquer la programmation dynamique pour tenter de diminuer la
complexité. L’idée est de décomposer le graphe en des sous ensemble de sommet,
pour chaque sous ensemble <script type="math/tex">S</script> on vérifie pour chaque sommet <script type="math/tex">u</script> de chaque sous ensemble
s’il existe une chaine couvrant les sommets de <script type="math/tex">S</script> et se terminant en <script type="math/tex">v</script></li>
</ol>

<h2 id="exercice-2">Exercice 2</h2>
<p>Nous pouvons utiliser le cours et le théorème de Dirac pour le montrer.</p>

<p><code class="language-plaintext highlighter-rouge">Théorème de Dirac</code> : Un graphe à <script type="math/tex">n</script> sommets (avec <script type="math/tex">n>3</script>) dont chaque sommet
est au moins de degré <script type="math/tex">\dfrac{n}{2}</script> est hamiltonien.</p>

<p>Pour rappel un graphe complet est un graphe simple dont tous les sommets sont
adjacents deux à deux. Chaque sommet à donc un degrés de <script type="math/tex">n-1 > n/2</script> pour
<script type="math/tex">n>3</script>. Ainsi tout graphe complet est hamiltonien.</p>

<h2 id="exercice-3">Exercice 3</h2>

<p>Comme dans l’exercice 1 nous avons discriminé deux méthodes pour déterminer si
un cycle est hamiltonien nous pouvons aussi discriminer deux méthodes exactes
pour résoudre le problème du voyageur de commerce. Dans un premier temps nous
pouvons utilser un pseudo code naïf. Cet algorithme à une complexité de <code class="language-plaintext highlighter-rouge">O(n!)</code>,
plus précisément <code class="language-plaintext highlighter-rouge">(n-1)!/2</code> si on pense à ne pas recalculer ce que l’on a déjà
calculé. On admet qu’il existe une fonction <code class="language-plaintext highlighter-rouge">permutation</code> permettant de fournir une permuttation d’un vecteur si il en existe une, zéro si elle ont toutes déjà été donnée.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Entrée : N vecteur de villes de taille n et une liste de coûts c(i,j)
Sortie : Liste de villes et coût total
Cout=0 //Cout total du chemin
ordre_permutation=0 //permet de retrouver le numéro de permutation pour retrouver la permutation
pour i allant de 0 à n
  tant que permutation(N)!=0
    poids_chemin_courant=0
    k=0
    pour i allant de 0 à n
      poids_chemin_courant=c(k,N[i])
      k=N[i]
    poid_chemin_courant+=c(k,0)
    cout=min(cout,poids_chemin_courant)
    ordre_permutation+=1;
retourner cout et ordre_permutation
</code></pre></div></div>

<p>Un autre algorithme pouvant être mis en place est un algorithme de programmation
dynamique, pour comprendre comment cela est possible il faut réecrire l’équation
de récurrence qui nous permet de choisir une ville. Soit un ensemble de
ville à visiter <script type="math/tex">C</script>. On note <script type="math/tex">chemin(C,i)</script> le chemin optimisé traversant
toutes les villes de <script type="math/tex">C</script> se terminant par la ville <script type="math/tex">i</script> et que nous voulons trouver la meilleur ville <script type="math/tex">j</script> suivante nous
devons trouver</p>

<script type="math/tex; mode=display">\begin{equation} chemin(C,j)=\min\{chemin(C\backslash\{j\},k)+c(k,j) \; \text{avec} \; k \in
C\}\end{equation}</script>

<p>A partir de cela nous pouvons remarquer une autre conséquence de
la construction du problème en effet le coût optimal pour résoudre le problème
consiste désormais à trouver la valeur de, notant <script type="math/tex">N</script> l’ensemble des villes
privées du point de départ</p>

<script type="math/tex; mode=display">\begin{equation}solution = \min\{chemin(N,j)+c(j,x)\}\end{equation}</script>

<p>A partir de ces valeurs l’équation récursive peut être utilisée pour construire
les valeurs <script type="math/tex">chemin(N,j)</script> pour tous les <script type="math/tex">C\subseteq N</script> et <script type="math/tex">j \in S</script>, en
parcourant l’ensemble à deux éléments, puis des ensemble à trois éléments etc
jusqu’à obtenir un ensemble à <script type="math/tex">n</script> éléments. Nous pouvons ensuite calculer <script type="math/tex">solution</script> grâce à ce procédé. Ensuite nous pouvons dérouler l’algorithme en trouvant une ville <script type="math/tex">v_{n-1}</script> telle que <script type="math/tex">chemin(N,v_{n-1})+c(v_{n-1})=solution</script>, puis identifier une ville <script type="math/tex">v_{n-2}</script> etc</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Entrée : Un ensemble de ville V, un point de départ v et un tableau c(i,j) permettant de donner le coup de la ville i à j
Sortie : Un chemin de coût minimal
Data[]=infty
Path[]
pour tout w dans V 
  Data({w},w)=c(v,w)
  P({w},w)=v
pour tout i allant de 2 à n
  pour tout S inclus dans V tel que |S|=i
    pour tout w dans S 
      pour tout u dans S
        z=Data(S\{w},u)+c(u,w)
        si z&lt;Data(S,w)
          D(S,w)=z
          Path(S,w)=u
retourner Path
</code></pre></div></div>

<p>La complexité de ce problème est en <code class="language-plaintext highlighter-rouge">O(n^2 2^n)</code></p>

<h2 id="exercice-4">Exercice 4</h2>
<p>On se place dans le cas où les coûts sont des déplacements et donc <script type="math/tex">c(u,v)=c(u,w)+c(w,v)</script></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Entrée : G=(V,E) un graphe complet et c(i,j) une fonction donnant le coup entre les villes i et j
Sortie : un chemin de coût minimal
Choisir un sommet r dans V comme ville initiale
Construire un arbre couvrant minimal T dans G à partir de r via l'algorithme de Krustal
Retourner le cycle hamiltonien H qui visite les sommets dans l'ordre trouvé par l'algorithme de Krustal
</code></pre></div></div>

<p>On veut maintenant prouver que l’algorithme est un algorithme d’approximation de facteur 2. On note <script type="math/tex">C^\ast</script> la tournée optimale et <script type="math/tex">C</script> la tournée courante. On cherche donc à montrer que <script type="math/tex">c(C)\leq2 c(C^\ast)</script>. Soit <script type="math/tex">T</script> l’arbre couvrant minimal, on a <script type="math/tex">c(T)\leq c(C^\ast)</script> (puisque C est construit avec l’algorithme de Krustal, C privé de l’arète qui forme le cycle est un arbre). Si l’on note <script type="math/tex">P</script> la liste formé par le parcours de <script type="math/tex">T</script> on obtient <script type="math/tex">c(P)=2c(T)</script> car chaque arête est visitée deux fois. On remarque que l’on peut supprimer un sommet de <script type="math/tex">P</script> (facilement mis en évidence avec un arbre à 3 sommets). Ainsi <script type="math/tex">c(P)\leq 2c(C^\ast)</script> et donc <script type="math/tex">c(C)\leq c(P) \leq 2 c(C^\ast)</script>. L’algorithme est donc un algorithme d’approximation de facteur 2.</p>

</div>
	</article>
</div><!-- Footer -->
<div id="footer">
  
  <!-- Copyright -->
  <ul class="copyright">
    
      <li>&copy;Informatique. All rights reserved.</li>
    
    <li>Design: <a href="http://html5up.net">HTML5 UP</a></li>
    <li>Jekyll integration: <a href="https://chrisbobbe.github.io/">Chris Bobbe</a></li>
  </ul>
  
</div></body>
</html>