<!DOCTYPE HTML>
<!--
Prologue by HTML5 UP
html5up.net | @ajlkn
Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
Jekyll integration by Chris Bobbe | chrisbobbe.github.io
-->
<html><head><!-- Robots -->
  <meta name="robots" content="index, follow" /><link rel="canonical" href="http://localhost:4000/assets/md/graph/graph_seance2403.html" /><!-- Title, description, author --><title>Problème du Labyrinthe (23/03) | Informatique - ENSEIRB-Matmeca</title>
  <meta name="description" content="Cours d&#39;informatique du Semestre 6 de l&#39;ENSEIRB-MATEMCA, année 2019/2020" />
  <meta name="author" content="Delpeuch Sébastien" />
  
  <!-- Open Graph -->
  <meta property="og:title" content="Problème du Labyrinthe (23/03) | Informatique - ENSEIRB-Matmeca" />
  <meta property="og:type" content="website" />
  <meta property="og:image" content="http://localhost:4000/assets/images/t%C3%A9l%C3%A9chargement.svg" />
  <meta property="og:url" content="http://localhost:4000/assets/md/graph/graph_seance2403.html" />
  <meta property="og:site_name" content="Informatique" />
  <meta property="og:description" content="Cours d&#39;informatique du Semestre 6 de l&#39;ENSEIRB-MATEMCA, année 2019/2020" />
  
  <!-- Styles -->
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!--[if lte IE 8]><script src="/assets/js/ie/html5shiv.js" defer></script><![endif]-->
  <link rel="stylesheet" href="/assets/css/main.css" />
  <!--[if lte IE 8]><link rel="stylesheet" href="/assets/css/ie8.css" /><![endif]-->
  <!--[if lte IE 9]><link rel="stylesheet" href="/assets/css/ie9.css" /><![endif]-->
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/all.css">

  <!-- Scripts -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js" defer></script>
  <script src="/assets/js/jquery.scrolly.min.js" defer></script>
  <script src="/assets/js/jquery.scrollzer.min.js" defer></script>
  <script src="/assets/js/skel.min.js" defer></script>
  <script src="/assets/js/util.js" defer></script>
  <!--[if lte IE 8]><script src="/assets/js/ie/respond.min.js" defer></script><![endif]-->
  <script src="/assets/js/main.js" defer></script>

</head><body><!-- Header -->
<div id="header">
  <div class="top"><!-- Logo -->
<div id="logo">
  <a href="http://localhost:4000/" id="home-link">
    <span class="image avatar48"><img src="/assets/images/t%C3%A9l%C3%A9chargement.svg" alt="Avatar of Delpeuch Sébastien" /></span>
    <h1 id="title">Informatique</h1>
    <p>ENSEIRB-Matmeca</p>
  </a>
</div><!-- Nav -->
<nav id="nav">
  <ul><li><a href="http://localhost:4000/" id="semestre-6-en-cours-link">
            <span class="icon fa-link">Semestre 6 - En cours</span>
          </a></li><li><a href="http://localhost:4000/Semestre_5.html" id="semestre-5-link">
            <span class="icon fa-check">Semestre 5</span>
          </a></li></ul>
</nav></div>
  <div class="bottom"><!-- Social Icons -->
<ul class="icons"><li><a href="https://github.com/Sdelpeuch" class="icon-b fa-github"><span class="label">GitHub</span></a></li><li><a href="mailto:sebastien.delpeuch@enseirb-matmeca.fr" class="icon fa-envelope"><span class="label">Email</span></a></li></ul>
</div>
</div>
<!-- Main -->
<div id="main">
	<!-- Page -->
	<article class="shade-two">
	  <div class="container">
			<header>
				<h2>Problème du Labyrinthe (23/03)</h2></header><h2 id="modélisation">Modélisation</h2>

<p>Voici le Labyrinthe sur lequel nous allons travailler</p>

<p><img src="/assets/images/graphe/labyrinthe.png" alt="alt text" /></p>

<p>L’idée est de trouver une modélisation simple pour pouvoir se déplacer sur le
graphe le modélisation se base sur les chemins possibles</p>

<p><img src="/assets/images/graphe/labyrinthe1.png" alt="alt text" />
<img src="/assets/images/graphe/labyrinthe2.png" alt="alt text" />
<img src="/assets/images/graphe/labyrinthe3.png" alt="alt text" /></p>

<h2 id="résolution-du-problème">Résolution du problème</h2>
<p>On peut trouver la sortie d’un labyrinthe avec 2 couleurs en “simulant” un
parcours en profondeur (<strong>DFS</strong>): Au lieu d’utiliser une mémoire globale de taille <code class="language-plaintext highlighter-rouge">n</code>
(la pile), on va utiliser un marquage local, à chaque nœud/arête, avec
uniquement 2 marqueurs/craies/cailloux de couleur.</p>

<ul>
  <li>Au lieu d’empiler un sommet, on va le marquer de la couleur 1</li>
  <li>Au lieu de dépiler un sommet, on doit vérifier que
    <ol>
      <li>tous les sommets voisins ont été visités</li>
      <li>revenir au sommet “père” La première opération est facile. La deuxième
l’est moins avec une mémoire locale.</li>
    </ol>
  </li>
</ul>

<ol>
  <li>
    <p>En effet, il faut détecter facilement qu’un voisin a déjà été visité : il
suffit d’y aller et si c’est le cas faire demi-tour … mais on veut éviter de
visiter de manière plusieurs fois la même arête. Nommons par commodité la salle
“courante” U. Je visite un voisin V de U et il se trouve que V a déjà été
visité. Je reviens donc en U. Je n’ai pas la mémoire des autres voisins de U.
Les ai-je visité ? Il se pourrait que cela soit le cas. Pour éviter cet écueil,
il suffit de marquer les arêtes. Une arête marquée indique que j’ai déjà suivi
le couloir correspondant. Cette opération est donc facile.</p>
  </li>
  <li>
    <p>Il faut pouvoir remonter au père donc distinguer 2 types de marquage : les
arêtes retour et les arêtes père. En résumé, la méthode est la suivante :</p>
    <ul>
      <li>Chaque nouvelle arête parcourue ou tout nouveau sommet traversé est marqué par
la couleur 1 (correspond à l’empilement d’un sommet dans le DFS)</li>
      <li>Si on arrive à un sommet marqué, on fait demi-tour en marquant l’arête avec la
couleur 2. Une arête “retour” est donc marqué par les couleurs 1 et 2 (aller
et retour)</li>
      <li>Si toutes les arêtes incidentes sont doublement marquées sauf une, on sait
qu’on a visité tous les voisins. Ainsi, l’arête restante simplement marqué est
l’arête “père”. Cela correspond à l’opération de dépilement de sommet du DFS.
Il faut remonter au père en marquant l’arête père 2.</li>
    </ul>
  </li>
</ol>

<p>La résolution se fait via l’algorithme de
<a href="https://en.wikipedia.org/wiki/Maze_solving_algorithm#Tr%C3%A9maux's_algorithm">Trémaux</a>
dont le fonctionnement est disponible en <a href="https://www.youtube.com/watch?v=gVSEJdSQZVQ">video</a></p>

<h2 id="pour-lundi-30-mars">Pour Lundi 30 mars</h2>
<ul>
  <li>Lire chapitre 9 sur les arbres couvrants:</li>
  <li>Dijkstra (PCC avec poids positif)</li>
  <li>Bellman-Ford (PPC avec poids négatif sans cycle absorbant, cad négatif)</li>
  <li>Algorithme de Prim (poids minimal, ajout de l’arête de poids minimal dont une extrémité a été visité – Dijskstra Like)</li>
  <li>Kruskal (tri des arêtes par poids croissant - facultatif)</li>
  <li>Chercher les meilleurs vidéos et mettre les liens sur discord d’ici vendredi</li>
  <li>Exercice : écrire un algorithme de complexité <code class="language-plaintext highlighter-rouge">O(n)</code> qui vérifie si un graphe est un arbre</li>
</ul>
</div>
	</article>
</div><!-- Footer -->
<div id="footer">
  
  <!-- Copyright -->
  <ul class="copyright">
    
      <li>&copy;Informatique. All rights reserved.</li>
    
    <li>Design: <a href="http://html5up.net">HTML5 UP</a></li>
    <li>Jekyll integration: <a href="https://chrisbobbe.github.io/">Chris Bobbe</a></li>
  </ul>
  
</div></body>
</html>