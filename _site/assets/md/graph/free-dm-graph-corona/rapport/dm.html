<!DOCTYPE HTML>
<!--
Prologue by HTML5 UP
html5up.net | @ajlkn
Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
Jekyll integration by Chris Bobbe | chrisbobbe.github.io
-->
<html><head><!-- Robots -->
  <meta name="robots" content="index, follow" /><link rel="canonical" href="http://localhost:4000/assets/md/graph/free-dm-graph-corona/rapport/dm.html" /><!-- Title, description, author --><title>&lt;i class=&quot;fas fa-project-diagram fa-2x&quot;&gt;&lt;/i&gt; Graphe - Devoir Maison propagation du Covid-19 | Informatique - ENSEIRB-Matmeca</title>
  <meta name="description" content="Cours d&#39;informatique du Semestre 6 de l&#39;ENSEIRB-MATEMCA, année 2019/2020" />
  <meta name="author" content="Delpeuch Sébastien" />
  
  <!-- Open Graph -->
  <meta property="og:title" content="&lt;i class=&quot;fas fa-project-diagram fa-2x&quot;&gt;&lt;/i&gt; Graphe - Devoir Maison propagation du Covid-19 | Informatique - ENSEIRB-Matmeca" />
  <meta property="og:type" content="website" />
  <meta property="og:image" content="http://localhost:4000/assets/images/t%C3%A9l%C3%A9chargement.svg" />
  <meta property="og:url" content="http://localhost:4000/assets/md/graph/free-dm-graph-corona/rapport/dm.html" />
  <meta property="og:site_name" content="Informatique" />
  <meta property="og:description" content="Cours d&#39;informatique du Semestre 6 de l&#39;ENSEIRB-MATEMCA, année 2019/2020" />
  
  <!-- Styles -->
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!--[if lte IE 8]><script src="/assets/js/ie/html5shiv.js" defer></script><![endif]-->
  <link rel="stylesheet" href="/assets/css/main.css" />
  <!--[if lte IE 8]><link rel="stylesheet" href="/assets/css/ie8.css" /><![endif]-->
  <!--[if lte IE 9]><link rel="stylesheet" href="/assets/css/ie9.css" /><![endif]-->
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/all.css">

  <!-- Scripts -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js" defer></script>
  <script src="/assets/js/jquery.scrolly.min.js" defer></script>
  <script src="/assets/js/jquery.scrollzer.min.js" defer></script>
  <script src="/assets/js/skel.min.js" defer></script>
  <script src="/assets/js/util.js" defer></script>
  <!--[if lte IE 8]><script src="/assets/js/ie/respond.min.js" defer></script><![endif]-->
  <script src="/assets/js/main.js" defer></script>

</head><body><!-- Header -->
<div id="header">
  <div class="top"><!-- Logo -->
<div id="logo">
  <a href="http://localhost:4000/" id="home-link">
    <span class="image avatar48"><img src="/assets/images/t%C3%A9l%C3%A9chargement.svg" alt="Avatar of Delpeuch Sébastien" /></span>
    <h1 id="title">Informatique</h1>
    <p>ENSEIRB-Matmeca</p>
  </a>
</div><!-- Nav -->
<nav id="nav">
  <ul><li><a href="http://localhost:4000/" id="semestre-6-en-cours-link">
            <span class="icon fa-link">Semestre 6 - En cours</span>
          </a></li><li><a href="http://localhost:4000/Semestre_5.html" id="semestre-5-link">
            <span class="icon fa-check">Semestre 5</span>
          </a></li></ul>
</nav></div>
  <div class="bottom"><!-- Social Icons -->
<ul class="icons"><li><a href="https://github.com/Sdelpeuch" class="icon-b fa-github"><span class="label">GitHub</span></a></li><li><a href="mailto:sebastien.delpeuch@enseirb-matmeca.fr" class="icon fa-envelope"><span class="label">Email</span></a></li></ul>
</div>
</div>
<!-- Main -->
<div id="main">
	<!-- Page -->
	<article class="shade-two">
	  <div class="container">
			<header>
				<h2><i class="fas fa-project-diagram fa-2x"></i> Graphe - Devoir Maison propagation du Covid-19</h2><p>Decou Nathan , Delpeuch Sébastien, Moinel Aurélien, Pringalle Antoine</p></header><script type="text/javascript" async="" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<p>Le but de ce devoir maison est d’utiliser l’algorithmique des graphes pour
modéliser une version simpliste de la propagation du Covid-19. Le devoir se
décompose en 3 parties d’implémentation, tout d’abord nous mettons en place les
différentes paramètres (mortalité, durée de maladie) et les différents graphes. Vient ensuite le rajout de
paramètres simples comme des tests sur la population etc. Finalement nous avons
tenté de rajouter des facteurs plus réalistes  à compléter.</p>

<p>Notre travail est résumé dans l’outil de visualisation que nous avons crée
disponible en fin de page.</p>

<h2 id="-partie-i---implémentation-dune-base-nathan--aurélien"><i class="fas fa-project-diagram"></i> Partie I - Implémentation d’une base (Nathan &amp; Aurélien)</h2>
<p>La première partie permet de définir les bases de la modélisation c’est à dire
les différents états, les différents paramètres, les règles de changement
d’état, les topologies de graphes étudiés et les différents modèles de ces
derniers. La population est pour l’instant considérée comme uniforme (chaque
individu est sujet à la maladie de la même manière), ils peuvent être dans
quatre états, Sain (<script type="math/tex">S</script>), Infecté (<script type="math/tex">M</script>), Guéri et donc imunisés (<script type="math/tex">G</script>) ou
décédé (<script type="math/tex">D</script>). De plus chaque personne suit les règles suivantes</p>
<ul>
  <li>Si une personne saine <script type="math/tex">X</script> fréquente une personne malade <script type="math/tex">Y</script> alors, avec la
probabilité <script type="math/tex">q</script>, <script type="math/tex">X</script> devient malade par l’intermédiaire de <script type="math/tex">Y</script> pour une
durée <script type="math/tex">r</script>.</li>
  <li>Si une personne est malade depuis <script type="math/tex">r</script> jours alors soit elle décède avec une
probabilité <script type="math/tex">p</script> soit elle devient immunisé avec une probabilité <script type="math/tex">(1-p)</script>.</li>
  <li>Une personne immunisée ou décédée ne change jamais d’état.</li>
  <li>Une personne décédée ne peut pas contaminer une personne saine.</li>
</ul>

<p>Nous allons aussi définir les différents graphes de contact permettant de
simuler les différentes relations de chaque individu, trois graphes sont alors
mis en oeuvre</p>
<ul>
  <li>Un graphe circulaire, les personnes sont numérotés de 1 à <script type="math/tex">n</script> et chaque
personne, numérotés <script type="math/tex">i</script>, est relié aux personnes <script type="math/tex">(i-1)</script> et <script type="math/tex">(i+1)</script>
modulo <script type="math/tex">n</script>,</li>
  <li>Un graphe aléatoire, on tire un graphe aléatoire de taille <script type="math/tex">n</script> de la manière
suivante. Chaque noeud choisit <script type="math/tex">k</script> noeuds choisis au hasard. Cela permet de
représenter de manière simpliste la population, chaque individu à un nombre
aléatoire de contact avec les autres individus</li>
  <li>Finalement le graphe mixe, issu de l’union du graphe circulaire et du graphe
aléatoire</li>
</ul>

<p>De plus nous définissons aussi 2 modèles de graphe</p>
<ul>
  <li>statique (graphe de confinement de paramère <script type="math/tex">k'</script>) : une personne confinée
fréquence <script type="math/tex">k' \leq k</script> personnes sélectionnées au hasard. Il n’est pas
autorisée à voir les autres personnes pendant le confinement.</li>
  <li>dynamique (graphe de baisse de fréquentation de paramètre <script type="math/tex">k'</script>) : chaque
jour, chaque personne est autorisée à voir <script type="math/tex">k'</script> personnes qu’elle
sélectionne parmi ses <script type="math/tex">k</script> contacts. Il peut donc voir des personnes
différentes d’un jour à l’autre</li>
</ul>

<p>Dans un premier temps nous allons définir la séquence de graphe <script type="math/tex">G_i</script>
permettant de réprésenter l’état du graphe <script type="math/tex">G</script> au jour <script type="math/tex">i</script>. Peu importe le
jour, les sommets du graphe ne change pas. Ainsi dans une première partie
d’initialisation nous construisons le graphe en fonction de la topologie choisie,
dans tous les cas le graphe possède <script type="math/tex">n</script> sommets. Ensuite vient la
construction des arêtes du graphe. Pour le graphe circulaire, cela est effectué
dans l’initialisation, en effet les individus ne sont reliés que à leurs voisins
de droite et de gauche, cela est indépendant du jour. Par construction ce graphe
est connexe.</p>

<p>De plus chaque jour, nous devons appliquer les règles de changement d’état à
tous les individus, ainsi peut importe la topologie du graphe nous parcourons le
graphe, si nous tombons sur une personne malade nous appliquons à tous ses
voisins une probabilité <script type="math/tex">q</script> de tomber malade, si l’un tombe malade nous
initialisons un compteur représentant la durée de sa maladie. Si nous tombons
sur une personne malade depuis une durée <script type="math/tex">r</script> nous appliquons la probabilité
<script type="math/tex">p</script> de décéder. A noter que si une personne décède la liste de ses voisins est
vidée.</p>

<p>Une fois cela présenté, nous pouvons réaliser une base de l’implémentation. Nous
définissons donc une classe python <code class="language-plaintext highlighter-rouge">individu</code>. Cela nous permet de renseigner
les informations importante sur chaque individu, son état, son identificateur,
le nombre de jour depuis lequel il est malade si il est malade. Finalement dans
cette version un individu possède aussi un tableau avec l’identificateur de ses
actuels voisins.</p>

<p>Résumons la construction de ce modèle. Tout d’abord nous créons une population
de taille <script type="math/tex">n</script>. Cela se fait en initialisant <script type="math/tex">n</script> individu et donc en temps
linéaire en fonction de <script type="math/tex">n</script>. Ensuite nous créons le graphe circulaire, nous
utilisons une matrice d’adjacence, nous parcourons tous les individus <script type="math/tex">i</script> et à
chaque fois nous mettons un 1 dans la case <script type="math/tex">(i-1)%n</script> et <script type="math/tex">(i+1)%n</script>. Dans le
même temps nous remplissons le tableau des voisins de chaque individu. La
création de ce graphe est donc réalisé en <code class="language-plaintext highlighter-rouge">O(n)</code> où <script type="math/tex">n</script> est
le nombre d’individu. Nous devons ensuite appliquer le modèle en fonction
de <script type="math/tex">k</script> ou <script type="math/tex">k'</script>, cette fonction à une complexité <code class="language-plaintext highlighter-rouge">O(n*k')</code> en effet il faut
pour chaque individu lui faire choisir <script type="math/tex">k'</script> contact parmis ses <script type="math/tex">k</script>
fréquentation. Dans le graphe circulaire <script type="math/tex">k</script> vaut toujours 2, ainsi <script type="math/tex">k'</script>
peut valoir 2 et donc cela ne change rien ou 1. A ce stade nous avons initialisé
correctement le graphe, la complexité de l’initialisation est majorée par
<code class="language-plaintext highlighter-rouge">O(n*m)</code> où <script type="math/tex">m</script> est le nombre moyen de voisins.</p>

<p>Passons maintenant au détail de la propagation jour par jour. Chaque jour nous
devons parcourir tous les individu. Si nous sommes dans un modèle dynamique nous
devons actualiser les voisins. Ensuite si l’individu est malade depuis <script type="math/tex">r</script>
jour, lui appliquer une chance de mourir, si l’individu est en contact avec des
malades lui appliquer une chance de devenir malade. Finalement nous ajoutons un jour
de maladie à tous les malades. Ainsi pour calculer l’état du graphe au jour
<script type="math/tex">i+1</script> nous avons une fonction de complexité è <code class="language-plaintext highlighter-rouge">O(n+m)</code> où <script type="math/tex">m</script> est le nombre
moyen de voisin d’un individu.</p>

<p>Nous pouvons à partir de cela établir notre code final pour le graphe circulaire en modèle
statique et dynamique. Nous initialisons dans un premiers temps le graphe et la
population. Nous faisons ensuite appel à la fonction de propagation jour par
jour le nombre de jours que nous voulons (par défaut 180), nous avons ajouté
certainnes fonctionnalités nous permettant de récupèrer chaque jour une image du
graphe et le nombre de malade, sain, remis ou décédés. <em>In fine</em> notre
algortihme principal à une complexité de <code class="language-plaintext highlighter-rouge">O(nbr jours * n * m)</code>.</p>

<p>Nous pouvons commencer, comme le sujet nous y invite, à simuler la propagation
dans une graphe circulaire, tout d’abord dans le modèle statique et dynamique
avec des populations de 100, 1000 et 10000 individu en prenant comme paramètres
<script type="math/tex">r=14, p=0.01,q=0.02, k=50</script> dans cette topologie la variation de <script type="math/tex">k'</script>
influe peu sur les résultats nous prenons <script type="math/tex">k'=2</script>.
Voici quelques animations permettant de visualiser la propagation dans les
différents graphes au fur et à mesure des jours.</p>

<p>GIF &amp; ANALYSE</p>
<ol>
  <li>GIF graphe + courbe individus, 100 individus k’=2</li>
  <li>GIF graphe + courbe individus, 1000 individus k’=2</li>
  <li>courbe individus, 10 000 individus k’=2</li>
</ol>

<p>Nous pouvons tout d’abord voir qu’il y a une propagation au fur et à mesure des
jours, cependant il apparait clairement que les résultats sont peu satisfaisant,
en effet le graphe circulaire est relativement simpliste et ne représente que
très peu les connexions humaines. Nous nous tournons donc vers la deuxième
topologie proposée, le graphe aléatoire. Celui ci relie les sommets de manière
aléatoire (il est à noter qu’il n’est pas forcément connexe). Pour gérer plus
facilement le modèle statique et dynamique nous remplissons dans
l’initialisation le tableau des voisins par <script type="math/tex">k</script> voisin choisis de manière
aléatoire, si nous sommes dans un modèle statique nous sélectionnons
aléatoirement pour chaque individu dans l’initialisation <script type="math/tex">k'</script> voisins parmi
ses <script type="math/tex">k</script> voisins. En revanche si nous sommes dans un modèle dynamique, à chaque
jour nous devons sélectionner aléatoirement <script type="math/tex">k'</script> voisins parmis ses <script type="math/tex">k</script>
contacts autorisés. Grâce à notre implémentation basé sur un tableau contenant
les <script type="math/tex">k</script> contacts possibles et un tableau contenant ses <script type="math/tex">k'</script> voisins pour le
jour <script type="math/tex">i</script> la complexité de l’initialisation et de la boucle principale reste
inchangée.</p>

<p>Nous pouvons alors réaliser des tests en prenant les mêmes paramètres que
précédemment avec une population de 1 000 et 10 000 individus. Pour ne pas faire trop de
graphes nous faisons trois tests avec <script type="math/tex">k'=2,25,50</script>, l’ensemble des variations
de <script type="math/tex">k'</script> peut être réalisé avec nos codes.</p>

<p>GIF &amp; ANALYSE</p>
<ol>
  <li>GIF graphe (à un k fixe) + gif courbe individus variation k , 1000 individus</li>
  <li>gif courbe individus variation k, 10 000 individus</li>
</ol>

<p>Les résultats sont plus satisfaisant en effet nous pouvons voir une rapide
propagation de l’épidémie dans la population, rappelons que l’idée de cette
partie est de réussir à mettre en place un graphe représentant une population
ainsi que des connexions entre les individus de manière se rapprochant le plus
de la réalité possible. Faisons un point sur les deux graphes présentés. Nous
avons d’une part un graphe circulaire, représentant des individus connectés
uniquement avec leurs voisins. D’autre part nous avons un graphe aléatoire qui
simule des connexions totalement aléatoire avec les autres personnes. Nous
allons donc maintenant utiliser un graphe mixte, union des deux qui nous permet
de simuler une population qui est en contact avec ses voisins et un nombre
aléatoire d’individus. Ce graphe est le graphe le plus représentatif d’une
population humaine, après cette partie nous n’utiliserons que ce dernier.</p>

<p>La boucle principale n’a que très peu de modifications, dans l’initialisation
nous établissons un graphe à <script type="math/tex">n</script> sommets, les arrêtes de ce derniers sont
définie telles que pour un individu <script type="math/tex">i</script> il soit voisin de <script type="math/tex">(i-1) \equiv n</script>
et <script type="math/tex">(i+1) \equiv n</script> et au maximum <script type="math/tex">k'-2</script> voisins choisi aléatoirement parmi
les <script type="math/tex">k</script> voisins (eux aussi choisis aléatoirement) qu’il a le droit de voir.
Grâce à notre implémentation des individus, nous pouvons réussir cette
initialisation en un temps <script type="math/tex">O(n+m)</script> où <script type="math/tex">m</script> est le nombre moyen de voisins.</p>

<p>Ensuite si nous regardons la propagation jour par jour, cette dernière ne change
pas des autres implémentations, si le modèle est statiques les arêtes sont
définies au dans l’initialisation et nous appliquons les règles de changements
d’états jours par jours. Si le modèle est dynamique, chaque jour nous modifions
les arêtes tels que chaque individu soit connecté à ses deux voisins et qu’il
soit connecté à au plus <script type="math/tex">k'-2</script> voisins choisi parmi ses <script type="math/tex">k</script> voisins
possibles. La boucle de simulation est donc en complexité <script type="math/tex">O(nbr jour * n *
m)</script>.</p>

<p>Nous pouvons alors réaliser des tests en prenant les mêmes paramètres que
précédemment</p>

<p>GIF &amp; ANALYSE</p>
<ol>
  <li>GIF graphe 1 000 individus, GIF courbe individus variation de k</li>
  <li>GIF courbe individus variation de k , 10 000 individus</li>
</ol>

<p>Nous avons donc définit une topologie de graphe et des modèles de graphe nous
permettant de simuler la propagation d’une maladie dans un population ayant des
intéractions ressemblant à des relations humaines. Cependant pour l’instant nous
laissons l’épidémie se développer naturellement.</p>

<h2 id="-partie-ii---rajout-de-tests-simples-sébastien--antoine"><i class="fas fa-project-diagram"></i> Partie II - Rajout de tests simples (Sébastien &amp; Antoine)</h2>
<p>Nous allons maintenant im</p>

<h2 id="-partie-iii---rajouts-de-facteurs-plus-réalistes"><i class="fas fa-project-diagram"></i> Partie III - Rajouts de facteurs plus réalistes</h2>

</div>
	</article>
</div><!-- Footer -->
<div id="footer">
  
  <!-- Copyright -->
  <ul class="copyright">
    
      <li>&copy;Informatique. All rights reserved.</li>
    
    <li>Design: <a href="http://html5up.net">HTML5 UP</a></li>
    <li>Jekyll integration: <a href="https://chrisbobbe.github.io/">Chris Bobbe</a></li>
  </ul>
  
</div></body>
</html>