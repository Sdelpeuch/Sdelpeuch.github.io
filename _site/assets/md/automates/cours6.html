<!DOCTYPE HTML>
<!--
Prologue by HTML5 UP
html5up.net | @ajlkn
Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
Jekyll integration by Chris Bobbe | chrisbobbe.github.io
-->
<html><head><!-- Robots -->
  <meta name="robots" content="index, follow" /><link rel="canonical" href="http://localhost:4000/assets/md/automates/cours6.html" /><!-- Title, description, author --><title>&lt;i class=&quot;fas fa-robot fa-2x&quot;&gt;&lt;/i&gt; Automate minimal et minimisation | Informatique - ENSEIRB-Matmeca</title>
  <meta name="description" content="Cours d&#39;informatique du Semestre 6 de l&#39;ENSEIRB-MATEMCA, année 2019/2020" />
  <meta name="author" content="Delpeuch Sébastien" />
  
  <!-- Open Graph -->
  <meta property="og:title" content="&lt;i class=&quot;fas fa-robot fa-2x&quot;&gt;&lt;/i&gt; Automate minimal et minimisation | Informatique - ENSEIRB-Matmeca" />
  <meta property="og:type" content="website" />
  <meta property="og:image" content="http://localhost:4000/assets/images/t%C3%A9l%C3%A9chargement.svg" />
  <meta property="og:url" content="http://localhost:4000/assets/md/automates/cours6.html" />
  <meta property="og:site_name" content="Informatique" />
  <meta property="og:description" content="Cours d&#39;informatique du Semestre 6 de l&#39;ENSEIRB-MATEMCA, année 2019/2020" />
  
  <!-- Styles -->
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!--[if lte IE 8]><script src="/assets/js/ie/html5shiv.js" defer></script><![endif]-->
  <link rel="stylesheet" href="/assets/css/main.css" />
  <!--[if lte IE 8]><link rel="stylesheet" href="/assets/css/ie8.css" /><![endif]-->
  <!--[if lte IE 9]><link rel="stylesheet" href="/assets/css/ie9.css" /><![endif]-->
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.0/css/all.css">

  <!-- Scripts -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js" defer></script>
  <script src="/assets/js/jquery.scrolly.min.js" defer></script>
  <script src="/assets/js/jquery.scrollzer.min.js" defer></script>
  <script src="/assets/js/skel.min.js" defer></script>
  <script src="/assets/js/util.js" defer></script>
  <!--[if lte IE 8]><script src="/assets/js/ie/respond.min.js" defer></script><![endif]-->
  <script src="/assets/js/main.js" defer></script>

</head><body><!-- Header -->
<div id="header">
  <div class="top"><!-- Logo -->
<div id="logo">
  <a href="http://localhost:4000/" id="home-link">
    <span class="image avatar48"><img src="/assets/images/t%C3%A9l%C3%A9chargement.svg" alt="Avatar of Delpeuch Sébastien" /></span>
    <h1 id="title">Informatique</h1>
    <p>ENSEIRB-Matmeca</p>
  </a>
</div><!-- Nav -->
<nav id="nav">
  <ul><li><a href="http://localhost:4000/" id="semestre-7-en-cours-link">
            <span class="icon fa-link">Semestre 7 - En cours</span>
          </a></li><li><a href="http://localhost:4000/Semestre_6.html" id="semestre-6-link">
            <span class="icon fa-check">Semestre 6</span>
          </a></li><li><a href="http://localhost:4000/Semestre_5.html" id="semestre-5-link">
            <span class="icon fa-check">Semestre 5</span>
          </a></li><li><a href="http://localhost:4000/CPBx.html" id="cpbx-link">
            <span class="icon fa-check">CPBx</span>
          </a></li></ul>
</nav></div>
  <div class="bottom"><!-- Social Icons -->
<ul class="icons"><li><a href="https://github.com/Sdelpeuch" class="icon-b fa-github"><span class="label">GitHub</span></a></li><li><a href="mailto:sebastien.delpeuch@enseirb-matmeca.fr" class="icon fa-envelope"><span class="label">Email</span></a></li></ul>
</div>
</div>
<!-- Main -->
<div id="main">
	<!-- Page -->
	<article class="shade-two">
	  <div class="container">
			<header>
				<h2><i class="fas fa-robot fa-2x"></i> Automate minimal et minimisation</h2></header><script type="text/javascript" async="" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<p>Cours inspiré du
<a href="https://moodle.bordeaux-inp.fr/pluginfile.php/31498/mod_resource/content/6/poly-if114-etd.pdf">polycopié</a>
de <a href="https://www.labri.fr/perso/herbrete/">Frédéric Herbreteau</a>.</p>

<style>
html {
 zoom: 0.80;
}
</style>

<p>Nous avons vu au chapitre précédent que tout langage régulier est accepté par un automate fini déterministe. Cependant, il n’y a pas un unique automate fini (déterministe) qui accepte un langage régulier</p>

<p>Comment comparer deux automates finis ? Par exemple, comment décider que les deux AFD de la figure suivantes acceptent le même langage ? Nous avons vu au <a href="./cours2">chapitre 2</a> comment calculer une expression régulière pour le langage accepté par un automate fini. Mais il n’y a pas de représentation canonique d’un langage régulier par une expression régulière, et la comparaison d’expressions régulières est au moins aussi difficile que la comparaison d’automates finis.</p>

<p><img class="image about center" src="/assets/images/automates/AFD2.png" alt="AFD2" title="Deux AFD acceptant les encodages binaires des entiers naturels pairs" /></p>

<p>Nous avons également vu au <a href="./cours1">chapite 1</a> et <a href="./cours2">2</a> qu’un automate fini est un algorithme pour résoudre les problèmes de décision représentés par des langages réugliers. Pour un problème de décision régulier donné, il existe une infinité d’automates finis qui l’acceptent. D’un point de vue pratique, il est pourtant important de choisir un petit automate, c’est à dire un algorithme avec aussi peu d’instructions que possible.</p>

<p>Tout d’abord nous montrons qu’il existe un automate minimal unique pour chaque langage régulier. Ceci va nous permettre de parler de représentation canonique de langages réuliers ou encore d’algorithmes minimaux pour les problèmes de décision réguliers. Puis nous présentons un algorithme qui calcule, à partir d’un automate fini déterministe <script type="math/tex">A</script> donné, l’automate minimal qui accepte <script type="math/tex">\mathcal{L}(A)</script>.</p>

<h2 id="-représentation-canonique-des-langages-réguliers"><i class="fas fa-robot"></i> Représentation canonique des langages réguliers</h2>

<h3 id="congruence-associée-à-un-langage">Congruence associée à un langage</h3>

<p>Nous montrons maintenant que l’existence d’une représentation canonique pour les langages réguliers est une propriété intrinsèque à ces langages.</p>

<p>Soit <script type="math/tex">L</script> un langage sur <script type="math/tex">\Sigma</script>. Deux mots <script type="math/tex">w</script> et <script type="math/tex">w'</script> sont <strong>congrus
(à droite</strong> modulo <script type="math/tex">L</script>, noté <script type="math/tex">w \sim_L w'</script>, si pour tout mot <script type="math/tex">x \in
\Sigma^\ast, w.x \in L</script> si et seulement si <script type="math/tex">w'.x \in L</script>. <script type="math/tex">w</script> et <script type="math/tex">w'</script> sont
dit <strong>indistinguables</strong> pour <script type="math/tex">L</script>. La congruence <script type="math/tex">\sim_L</script> induit une relation
d’équivalence. Nous notons <script type="math/tex">[w]_{\sim_L} = \{w' | w \sim_L w'\}</script> la classe
d’équivalence de <script type="math/tex">w</script> pour <script type="math/tex">\sim_L</script>.</p>

<p>Intuitivement, si deux mots <script type="math/tex">u</script> et <script type="math/tex">v</script> ne sont pas congrus modulo <script type="math/tex">L</script>,
alors il existe un mot <script type="math/tex">x</script> tel que <script type="math/tex">u.x \in L</script> et <script type="math/tex">v.x \notin L</script> (ou
inversement). Ainsi, un automate fini qui accepte <script type="math/tex">L</script>, doit, lorsqu’il lit
<script type="math/tex">u.x</script> mémoriser une information suffisante pour ne pas confondre <script type="math/tex">u</script> et
<script type="math/tex">v</script>, et <em>in fine</em> accepter <script type="math/tex">u.x</script>. <em>A contrario</em>, si <script type="math/tex">u</script> et <script type="math/tex">v</script> sont
congrus modulo <script type="math/tex">L</script>, un automete fini qui accepte <script type="math/tex">L</script> n’est plus obligé de
distinguer <script type="math/tex">u</script> et <script type="math/tex">v</script> puisque <script type="math/tex">u.x</script> et <script type="math/tex">v.x</script> conduisent au même verdict.
Un automate fini mémorise l’information au moyen de ses états. Ainsi, dans le
cas où <script type="math/tex">u</script> et <script type="math/tex">v</script> ne sont pas congrus modulo <script type="math/tex">L</script>, afin de distinguer <script type="math/tex">u</script>
et <script type="math/tex">v</script>, la lecture de ces mots doit conduire l’automate dans deux états
distincts. Et inversement, lorsque <script type="math/tex">u</script> et <script type="math/tex">v</script> sont congrus modulo <script type="math/tex">L</script>,
leur lecteur peut conduire dans le même état puisqu’il n’est pas nécessaire de
les distinguer. Sachant qu’un automate fini possède un nombre fini d’états, et
que tout langage régulier est accepté par un automate fini, nous pouvons en
déduire une nouvelle caractérisation des langages réguliers.</p>

<p>Soit <script type="math/tex">A=(Q,\Sigma,\delta,I,F)</script> un automate fini. Le <strong>langage de l’état</strong> <script type="math/tex">q
\in Q</script> est défini par</p>

<script type="math/tex; mode=display">\mathcal{L}(A,q)=\{w \in \Sigma^\ast | q \stackrel{w}{\rightarrow} q' \;
\text{avec} \; q' \in F\}</script>

<p>Le <strong>co-langage de l’état</strong> <script type="math/tex">q \in Q</script> est défini par</p>

<script type="math/tex; mode=display">co\mathcal{L}(A,q)=\{w \in \Sigma^\ast | \exists q_0 \in I, q_0
\stackrel{w}{\rightarrow} q\}</script>

<h4 id="théorème-congruence-droite-et-régularité">Théorème (Congruence droite et régularité).</h4>

<p>Un langage <script type="math/tex">L</script> est régulier si et seulement si la congruence <script type="math/tex">\sim_L</script> est
d’index fini.</p>

<h3 id="automate-minimal">Automate minimal</h3>

<p>Nous nous intéressons maintenant à une notion d’automate minimal reconnaissant
un langage régulier donné. Nous montrons que chaque état de cet automate
correspond à une des classes d’équivalence de <script type="math/tex">\sim_L</script>. Ses transitions
correspondent au passage d’un classe à l’autre : depuis la classe d’équivalence
de <script type="math/tex">w</script>, la lecture d’un symbole <script type="math/tex">s</script> conduit à la classe d’équivalence de
<script type="math/tex">w.s</script>.</p>

<p>Soit <script type="math/tex">L</script> un langage régulier sur un alphabet <script type="math/tex">\Sigma</script>. L’<strong>automate fini
minimal</strong> <script type="math/tex">afmin(L)=(Q,\Sigma,\delta,q_0,F)</script> qui accepte <script type="math/tex">L</script> est défini par</p>
<ul>
  <li>
    <script type="math/tex; mode=display">Q=\{|w|_{\sim_L} | w \in \Sigma^\ast\}</script>
  </li>
  <li>
    <script type="math/tex; mode=display">\delta=\{(|w|_{\sim_L},s,[w.s]_{\sim_L}) | s \in \Sigma^\ast\}</script>
  </li>
  <li>
    <script type="math/tex; mode=display">q_0=[\epsilon]_{\sim_L}</script>
  </li>
  <li>
    <script type="math/tex; mode=display">F=\{[w]_{\sim_L} | w \in \Sigma^\ast \; \text{et} \; [w]_{\sim_L}\subseteq
L\}</script>
  </li>
</ul>

<p>Notons que <script type="math/tex">afmin(L)</script> est un automate déterministe et complet</p>

<h4 id="théorème">Théorème.</h4>
<p>Pour tout langage régulier <script type="math/tex">L</script>, <script type="math/tex">afmin(L)</script> est le plus petit automate fini
déterministe et complet tel que <script type="math/tex">\mathcal{L}(afmin(L))=L</script></p>

<h2 id="-minimisation-des-automates-finis"><i class="fas fa-robot"></i> Minimisation des automates finis</h2>

<p>La définition d’un automate minimal nous permet de prouver l’existence et
l’unicité de l’automate minimal qui accepte un langage <script type="math/tex">L</script> donné. Cependant,
elle ne permet pas de construire <script type="math/tex">afmin(L)</script> : il faudrait énumérer tous les
mots de <script type="math/tex">\Sigma^\ast</script> pour connaître l’ensemble de ses états. Nous présentons
maintenant un algorithme qui permet de calculer <script type="math/tex">afmin(L)</script> à partir d’un
automate <script type="math/tex">A</script> connu qui accepte <script type="math/tex">L</script>.</p>

<p>Soit <script type="math/tex">A=(Q,\Sigma,\delta,q_0,F)</script> un AFD supposé non minimal. nous pouvons
maintenant caractériser la non mminimalité en considérant les langages acceptés
depuis chacun des états de <script type="math/tex">A</script>. Deux états <script type="math/tex">q,q' \in Q</script> sont dits
<strong>équivalents</strong> si <script type="math/tex">\mathcal{L}(A,q)=\mathcal{L}(A,q')</script>. On note <script type="math/tex">\equiv_Q</script>
la relation d’équivalence ainsi définie.</p>

<p>L’équivalence entre états doit être rapprochée de la congruence de
<script type="math/tex">\mathcal{L}(A)</script>. En effet, supposons que <script type="math/tex">q_0 \stackrel{w}{\rightarrow} q</script>
et <script type="math/tex">q_0 \stackrel{w'}{\rightarrow} q'</script> pour deux mots <script type="math/tex">w,w' \in
\Sigma^\ast</script>. Alors, puisque <script type="math/tex">\mathcal{L}(A,q) = \mathcal{L}(A,q')</script>, pour
tout mot <script type="math/tex">x \in \Sigma^\ast, w.x</script> est accepté par <script type="math/tex">A</script> si et seulement
<script type="math/tex">w'.x</script> est accepté par <script type="math/tex">A</script>. Il vient alors <script type="math/tex">w \sim_{\mathcal{L}(A)}w'</script>.
L’équivalence entre <script type="math/tex">\equiv_Q</script> et <script type="math/tex">\sim_K</script> est prouvée plus tard. Un
automate fini <script type="math/tex">A</script> n’est donc pas minimal si et seulement si</p>
<ul>
  <li>il possède (au moins) un état inaccessible : il existe <script type="math/tex">q\in Q</script> tel que pour
tout <script type="math/tex">w \in \Sigma^\ast, q_0 \stackrel{w}{\nrightarrow} q</script></li>
  <li>ou il possède deux états distincts <script type="math/tex">q,q' \in Q</script> qui sont équivalents :
<script type="math/tex">\mathcal{L}(A,q)=\mathcal{L}(A,q')</script></li>
</ul>

<p>L’algorithme de minimisation d’un automate <script type="math/tex">A</script> procède donc en deux étapes :
tout d’abord la suppression des états inaccessibles de <script type="math/tex">A</script>, puis la fusion de
ses états équivalents.</p>

<p><img class="image about center" src="/assets/images/automates/AFD3.png" alt="AFD3" title="Automate fini déterministe et sa partie accessible" /></p>

<h3 id="elimination-des-états-inaccessibles">Elimination des états inaccessibles</h3>

<p>L’ensemble des <strong>états accessibles</strong> d’un automate fini
<script type="math/tex">A=(Q,\Sigma,\delta,I,F)</script> est défini par</p>

<script type="math/tex; mode=display">access(A)=\{q \in Q | \exists q_0 \in I, \exists w \in \Sigma^\ast. q_0
\stackrel{w}{\rightarrow} q\}</script>

<p>Intuitivement, les états accessibles d’un automate fini
<script type="math/tex">A=(Q,\Sigma,\delta,I,F)</script> sont les états <script type="math/tex">q</script> pour lesquels il existe une
séquence de transitions partant d’un état initial et menant jusqu’à <script type="math/tex">q</script>.</p>

<p>La restriction d’un automate fini <script type="math/tex">A=(Q,\Sigma,\delta,I,F)</script> à sa <strong>partie
accessible</strong> est l’automate fini <script type="math/tex">eqacc(A)=(Q',\Sigma,\delta',I,F')</script> défini
par</p>
<ul>
  <li>premièrement <script type="math/tex">Q'=access(A)</script></li>
  <li>de plus <script type="math/tex">\delta'=\delta \cap (Q' \times \Sigma \times Q')</script></li>
  <li>et <script type="math/tex">F'=F \cap Q'</script></li>
</ul>

<p>Remarquons que si <script type="math/tex">A</script> est déterministe (resp complet) alors <script type="math/tex">eqacc(A)</script> est
déterministe (resp complet)</p>

<p>La supression des états inaccessibles d’un automate fini ne modifie pas le
langage accepté par celui-ci. Cela vient du fait que, par définition, aucun état
inaccessible ne peut être rencontré sur une exécution (acceptante) de
l’automate.</p>

<h4 id="théorème-1">Théorème.</h4>

<p>Pour tout automate fini <script type="math/tex">A</script>,<script type="math/tex">\mathcal{L}(eqacc(A))=\mathcal{L}(A)</script></p>

<p>Le calcul de <script type="math/tex">access(A)</script> correspond au plus petit point fixe de la fonction
<script type="math/tex">Acc : X \rightarrow X \cup \{q' \in Q | \exists q \in X.\exists s \in
\Sigma.(q,s,q') \in \delta \}</script> contenant les états initiaux <script type="math/tex">I</script>. On peut
calculer par itérations successives</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align*} Acc(0) &= I \\ Acc(n+1) &= Acc(n) \cup \{q' \in Q | \exists q
\in Acc(n). \exists s \in \Sigma. (q,s,q') \in \delta\} \end{align*} %]]></script>

<p>Intuitivement, <script type="math/tex">Acc(n)</script> est l’ensemble des états pour lesquels il existe une
séquence d’au plus <script type="math/tex">n</script> transitions menant d’un état initial jusqu’à eux. Nous
calculons donc successivement <script type="math/tex">Acc(0)</script>, puis <script type="math/tex">Acc(1)</script> en utilisant
<script type="math/tex">Acc(0)</script>, puis <script type="math/tex">Acc(2)</script> à partir de <script type="math/tex">Acc(1)</script>, et ainsi de suite jusqu’au
point fixe obtenu lorsque <script type="math/tex">Acc(n)=Acc(n-1)</script> pour une valeur donnée de <script type="math/tex">n</script>.
L’algorithme <code class="language-plaintext highlighter-rouge">EtatsAccessibles</code> calcule le plus petit point fixe de <script type="math/tex">Acc</script>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Entrée : Un automate fini A=(Q,Σ,δ,I,F)
Sortie : access(A) l'ensemble des états accessibles de A

EtatsAccessibles(A):
debut 
    Acc  &lt;- I
    Acc' &lt;- ∅
    tant que (Acc != Acc') faire
        Acc' &lt;- Acc
        Acc  &lt;- Acc' u {q' ∈ Q | ∃ q ∈ Acc'.∃ s ∈ Σ .(q,s,q') ∈ δ}
    fin tant que 
    
    retourner Acc
fin 
</code></pre></div></div>

<h4 id="théorème-2">Théorème</h4>

<p>Pour tout automate <script type="math/tex">A=(Q,\Sigma,\delta,I,F)</script>, l’algorithme <code class="language-plaintext highlighter-rouge">EtatsAccessibles</code>
calcule <script type="math/tex">access(A)</script> en temps <script type="math/tex">\mathcal{O}(Card(Q))</script></p>

<h3 id="fusion-des-états-équivalents">Fusion des états équivalents</h3>

<p>Nous considérons maintenant des automates finis déterministes et complets, sans
états inaccessibles. Nous avons vu au <a href="./cours5">chapitre 5</a> comment
déterminiser tout AFN. Tout automate peut être rendu complet par la procédure de
complétude vue au chapitre 1. Enfin, la section précédente décrit comment
calculer l’ensemble des états accessibles d’un automate fini, puis comment le
restreindre à sa partie accessible.</p>

<p>Il nous reste maintenant à fusionner les états équivalents de l’automate <script type="math/tex">A</script>,
c’est à dire les états <script type="math/tex">q</script> et <script type="math/tex">q'</script> tels que
<script type="math/tex">\mathcal{L}(A,q)=\mathcal{L}(A,q')</script>. Pour cela, il faut donc calculer quels
états de <script type="math/tex">A</script> acceptent le même langage c’est à dire la relation <script type="math/tex">\equiv_Q</script>.</p>

<p>Une fois connue la relation <script type="math/tex">\equiv_Q</script>, nous pouvons définir l’automate fini
minimal qui accepte le même langage que l’automate <script type="math/tex">A</script> donné.</p>

<p>Soit <script type="math/tex">A=(Q,\Sigma,\delta,q_0,F)</script> un automate fini déterministe, complet et
sans états inaccessibles. L’<strong>automate minimal équivalent</strong> à <script type="math/tex">A</script> est
<script type="math/tex">eqmin(A)=(Q',\Sigma,\delta',q'_0,F')</script> défini par</p>
<ul>
  <li>
    <script type="math/tex; mode=display">Q'=\{|q|_{\equiv_Q} | q \in Q\}</script>
  </li>
  <li>
    <script type="math/tex; mode=display">\delta'=\{|q|_{\equiv_Q},s,[q']_{\equiv_Q} | (q,s,q') \in \delta\}</script>
  </li>
  <li>
    <script type="math/tex; mode=display">q'_0=[q_0]_{\equiv_Q}</script>
  </li>
</ul>

<p>Nous montrons maintenant que l’automate minimal équivalent à <script type="math/tex">A</script> correspond à
<script type="math/tex">afmin(\mathcal{L}(A))</script>, l’automate minimal qui accepte le langage accepté par
<script type="math/tex">A</script>.</p>

<h4 id="théorème-3">Théorème.</h4>

<p>Pour tout automate fini <script type="math/tex">A=(Q,\Sigma,\delta,q_0,F)</script> déterministe complet et
sans états inaccessibles, <script type="math/tex">eqmin(A)=afmin(\mathcal{L}(A))</script>.</p>

<p>Les relations <script type="math/tex">\sim_L</script> et <script type="math/tex">\equiv_Q</script> sont équivalentes pour
<script type="math/tex">A=(Q,\Sigma,\Êelta,q_0,F)</script> tel que <script type="math/tex">\mathcal{L}(A)=L</script>. Mais en pratique,
pour calculer <script type="math/tex">\sim_L</script> ou <script type="math/tex">\equiv_Q</script>, il est nécessaire de travailler sur
une structure finie. <script type="math/tex">L</script> est en général infini, mais nous pouvons travailler
soit sur une expression régulière de langage <script type="math/tex">L</script>, soit sur un automate fini
qui accepte <script type="math/tex">L</script>. Nous présentons donc l’algorithme <code class="language-plaintext highlighter-rouge">Partition</code> de calcul de
<script type="math/tex">\equiv_Q</script> pour un automate fini déterministe complet et sans états
inaccessibles <script type="math/tex">A=(Q,\Sigma,\delta,q_0,F)</script>. L’algorithme <code class="language-plaintext highlighter-rouge">Partition</code> maintient
un ensemble <script type="math/tex">P</script> de couples d’états <script type="math/tex">(q,q')</script> tels que</p>
<ul>
  <li>si <script type="math/tex">(q,q') \notin P</script>, alors <script type="math/tex">q \notequiv_Q q'</script></li>
  <li>et si <script type="math/tex">(q,q') \in P</script>, on fait l’hypothèse que <script type="math/tex">p \equiv_Q q'</script></li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Entree: A=(Q,Sigma,delta,q_0,F) AFD complet sans états inacssibles 
Sortie: P telle que (q,q') dans P si et seulement si q equiv q'

Partition(A)
debut
    P' &lt;- Q . Q 
    P  &lt;- Q . Q
    pour tout q dans F et q' pas dans F faire 
        retirer (q,q') et (q',q) de P 
    tant que (P différent P') faire
        P' &lt;- P
        pour tout (q,q') dans P faire
            pour tout s dans Sigma faire 
                si (succ(q,s),succ(q',s)) pas dans P' alors
                    retirer (q,q') et (q',q) de P 
                fin si
            fin pour
        fin pour 
    fin tant que 
    retourner P 
fin
</code></pre></div></div>

<p>Le principe de l’algorithme est de faire tendre la relation <script type="math/tex">P</script> vers
<script type="math/tex">\equiv_Q</script> par raffinements successifs en retirant les couples <script type="math/tex">(q,q')</script> de
<script type="math/tex">P</script> dès que l’hypothèse <script type="math/tex">q \equiv_Q q'</script> est invalidée.</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">Partition</code> fait l’hypothèse initiale que tous les états sont équivalents
pour <script type="math/tex">\equiv_Q</script></li>
  <li>nous savons que pour tous états <script type="math/tex">q,q' \in Q</script> tels que <script type="math/tex">q \in F</script> et <script type="math/tex">q'
\notin F, q \notequiv_Q q'</script> puisque <script type="math/tex">\epsilon \in \mathcal{L}(A,q)</script> alors
que <script type="math/tex">\epsilon \notin \mathcal{L}(A,q')</script>. La première boucle retire donc de
<script type="math/tex">P</script> toutes les paires d’états distinguables selon ce critère</li>
  <li>enfin, supposons que <script type="math/tex">(q,q') \in P</script> et qu’il existe un symbole <script type="math/tex">s \in
\Sigma</script> et deux états <script type="math/tex">p,p' \in Q</script> tels que <script type="math/tex">q \stackrel{s}{\rightarrow}
p</script> et <script type="math/tex">q' \stackrel{s}{\rightarrow} p'</script> avec <script type="math/tex">(p,p') \notin P</script>. Alors
nous avons la certitude <script type="math/tex">q \notequiv_Q q'</script> puisque <script type="math/tex">\mathcal{L}(A,p)
\notin \mathcal{L}(A,p')</script> implique que <script type="math/tex">s . \mathcal{L}(A,p) \notin s
. \mathcal{L}(A,p')</script> et <script type="math/tex">A</script> est déterministe. De tels couples <script type="math/tex">(q,q')</script>
sont détectés et éliminés de <script type="math/tex">P</script> dans la boucle tant ue.</li>
</ol>

<p>Le point fixe est atteint lorsque <script type="math/tex">P=P'</script>, <script type="math/tex">P'</script> conservant la valeur de <script type="math/tex">P</script>
au raffinement précédent, donc lorsque <script type="math/tex">O</script> ne contient plus que des couples
<script type="math/tex">(q,q')</script> tels que <script type="math/tex">q \equiv_Q q'</script></p>

<h4 id="théorème-4">Théorème.</h4>

<p>Pour tout AFD complet sans états inaccessibles <script type="math/tex">A=(Q,\Sigma,\delta,q_0,F)</script>,
l’algorithme précédant calcule <script type="math/tex">\equiv_Q</script> en temps <script type="math/tex">\mathcal{O}(Card(\Sigma)
\times Card(Q)^4)</script></p>

</div>
	</article>
</div><!-- Footer -->
<div id="footer">
  
  <!-- Copyright -->
  <ul class="copyright">
    
      <li>&copy;Informatique. All rights reserved.</li>
    
    <li>Design: <a href="http://html5up.net">HTML5 UP</a></li>
    <li>Jekyll integration: <a href="https://chrisbobbe.github.io/">Chris Bobbe</a></li>
  </ul>
  
</div></body>
</html>