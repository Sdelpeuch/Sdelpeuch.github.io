<!DOCTYPE html>
<html lang="en-Us"><head>
  <meta charset="utf-8">
  <title>La couche objet - Partie 2 : Constructeur, Destructeurs, Pointeur this, Statique, Surcharge</title>

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Semestre 7 de l&#39;ENSEIRB-MATEMECA">
  <meta name="author" content="Sébastien">
  <meta name="generator" content="Hugo 0.74.3" />

  <!-- plugins -->
  
  <link rel="stylesheet" href="https://Sdelpeuch.github.io/plugins/bootstrap/bootstrap.min.css">
  
  <link rel="stylesheet" href="https://Sdelpeuch.github.io/plugins/Ionicons/css/ionicons.min.css">
  
  <link rel="stylesheet" href="https://Sdelpeuch.github.io/plugins/magnific-popup/magnific-popup.css">
  
  <link rel="stylesheet" href="https://Sdelpeuch.github.io/plugins/slick/slick.css">
  

  <!-- Main Stylesheet -->
  
  <link rel="stylesheet" href="https://Sdelpeuch.github.io/scss/style.min.css" media="screen">

  <!--Favicon-->
  <link rel="shortcut icon" href="https://Sdelpeuch.github.io/images/favicon.png" type="image/x-icon">
  <link rel="icon" href="https://Sdelpeuch.github.io/images/favicon.png" type="image/x-icon">

</head><body>
<!-- preloader start -->
<div class="preloader">
  
</div>
<!-- preloader end -->

<header class="navigation">
  <div class="container">
    <div class="row">
      <div class="col-md-12">
        
        <nav class="navbar">
          
          <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navigation">
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">
              <img src="https://Sdelpeuch.github.io/images/telechargement.png" alt="Semestre 7" width="65px" class="img-responsive">
            </a>
          </div>
          
          <div class="collapse navbar-collapse" id="navigation">
            <ul class="nav navbar-nav navbar-right">
              
              
              <li><a href="/">Accueil</a></li>
              
              
              
              <li class="dropdown">
                <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true"
                  aria-expanded="false">Semestre 7 <span class="ion-ios-arrow-down"></span></a>
                <ul class="dropdown-menu">
                  
                  <li><a href="/semestre7/compilation/">Compilation</a></li>
                  
                  <li><a href="/semestre7/gl">Génie Logiciel</a></li>
                  
                  <li><a href="/semestre7/poo">POO</a></li>
                  
                  <li><a href="/semestre7/cpp">Programmation C&#43;&#43;</a></li>
                  
                  <li><a href="/semestre7/quantique">Quantique</a></li>
                  
                  <li><a href="/semestre7/bdd">SGBD</a></li>
                  
                  <li><a href="/semestre7/prog_sys/">Système</a></li>
                  
                  <li><a href="/semestre7/tcp">TCP/IP</a></li>
                  
                </ul>
              </li>
              
              
              
              <li><a href="/semestre6/semestre_6">Semestre 6</a></li>
              
              
              
              <li><a href="/semestre5/semestre_5">Semestre 5</a></li>
              
              
              
              <li><a href="/contact">Contact</a></li>
              
              
              
              <li><a href="/cpbx">CPBx</a></li>
              
              

              
            </ul>
          </div>
        </nav>
      </div>
    </div>
  </div>
</header>

<section class="page-title bg-2" style="background-image: url('https://Sdelpeuch.github.io/images/banner/cpp.jpg');">
  <div class="container">
    <div class="row">
      <div class="col-md-12">
        <div class="block">
          <h1>La couche objet - Partie 2 : Constructeur, Destructeurs, Pointeur this, Statique, Surcharge</h1>
          <p></p>
        </div>
      </div>
    </div>
  </div>
</section>


<section class="page-wrapper">
	<div class="container">
		<div class="row">
			<div class="col-md-8">
				<div class="post post-single">
					<h2 class="post-title">La couche objet - Partie 2 : Constructeur, Destructeurs, Pointeur this, Statique, Surcharge</h2>
					<div class="post-meta">
						<ul>
              <li><i class="ion-calendar"></i> November 4, 2020</li>
              
              
              
              
              
              
              <li><i class="ion-pricetags"></i> 
                
                <a href="/tags/c&#43;&#43;">C&#43;&#43;</a>
								
              </li>
            </ul>
					</div>
					
					
					
					<div class="post-content post-excerpt">
						<h2 id="constructeurs-et-destructeurs">Constructeurs et destructeurs</h2>
<p>Le <em>constructeur</em> et le <em>destructeur</em> sont deux méthodes particulières qui sont
appelées respectivement à la création et à la destruction d&rsquo;un objet. Toute
classe a un constructeur et un destructeur par défaut, fournis par le
compilateur. Ces constructeurs et destructeurs appellent les constructeurs par
défaut et les destructeurs des classes de base et des données membre de la
classe, mais en dehors de cela, ils ne font absolument rien. Il est donc souvent
nécessaire de les redéfinir afin de gérer certaines actions qui doivent avoir
lieu lors de la création d&rsquo;un objet et de leur destruction. Par exemple, si
l&rsquo;objet doit contenir des objets allouées dynamiquement, il faut leur réserver
de la mémoire à la création de l&rsquo;objet ou au moins mettre les pointeurs
correspondants à NULL. À la destruction de l&rsquo;objet, il convient de restituer la
mémoire allouée, s&rsquo;il en a été alloué. On peut trouver bien d&rsquo;autres situations
où une phase d&rsquo;initialisation et une phase de terminaison son nécessaires.</p>
<p>Dés qu&rsquo;un constructeur ou un destructeur a été défini par l&rsquo;utilisateur, le
compilateur ne définit plus automatiquement le constructeur ou le destructeur
par défaut correspondant. En particulier, si l&rsquo;utilisateur définit un
constructeur prenant des paramètres, il ne sera plus possible de construire un
objet simplement, sans fournir les paramètres à ce constructeur, à moins bien
entendu de définir également un constructeur qui ne prenne pas de paramètres.</p>
<h3 id="définition-des-constructeurs-et-des-destructeurs">Définition des constructeurs et des destructeurs</h3>
<p>Le constructeur se définit comme une méthode normale. Cependant, pour que le
compilateur puisse la reconnaître en tant que constructeur, les deux conditions
suivantes doivent vérifiées :</p>
<ul>
<li>elle doit porter le même nom que la classe</li>
<li>elle ne doit avoir aucun type, pas même le type void</li>
</ul>
<p>Le destructeur doit également respecter ces règles. Pour différencier du
constructeur, son nom sera toujours précédé du signe tilde.</p>
<p>Un constructeur est appelé automatiquement lors de l&rsquo;instanciation de l&rsquo;objet.
Le destructeur est appelé automatiquement lors de sa destruction. Cette
destruction a lieu lors de la sortie du bloc de portée courante pour les objets
de classe de stockage <code>auto</code>. Pour les objets alloués dynamiquement, le
constructeur et le destructeur sont appelés automatiquement par les expressions
qui utilisent les opérateurs <code>new, new[], delete, delete[]</code>. C&rsquo;est pour cela
qu&rsquo;il est recommandé de les utiliser à la place des fonctions <code>malloc</code> et <code>free</code>
du C pour créer dynamiquement des objets. De plus, il ne faut pas utiliser
<code>delete</code> ou <code>delete[]</code> sur des pointeurs de type void, car il n&rsquo;existe pas
d&rsquo;objets de type void. La compilateur ne peut donc pas déterminer quel est le
destructeur à appeler avec ce type de pointer.</p>
<p>Le constructeur est appelé après l&rsquo;allocation de la mémoire de l&rsquo;objet et le
destructeur est appelé avant la libération de cette mémoire. La gestion de
l&rsquo;allocation dynamique de mémoire avec les classes est ainsi simplifiée. Dans le
cas des tables, l&rsquo;ordre de construction est celui des adresses croissantes, et
l&rsquo;ordre de destruction est celui des adresses décroissantes. C&rsquo;est dans cet
ordre que les constructeurs et destructeurs de chaque élement du tableau sont
appelés.</p>
<p>Les constructeurs pourront avoir des paramètres. Ils peuvent donc être
surchargés, mais pas les destructeurs. Cela est dû au fait qu&rsquo;en général on
connaît le contexte dans lequel un objet est créé, mais qu&rsquo;on ne peut pas
connaître le contexte dans lequel il est détruit : il ne peut donc y avoir qu&rsquo;un
seul destructeur. Les constructeurs qui ne prennent pas de paramètre ou dont
tous les paramètres ont une valeur par défaut, remplacent automatiquement les
constructeurs par défaut définis par le compilateur lorsqu&rsquo;il n&rsquo;y a aucun
constructeur dans les classes. Cela signifie que ce sont ces constructeurs qui
seront appelés automatiquement par les constructeurs par défaut des classes
dérivées.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">chaine</span>    <span style="color:#75715e">// Implémente une chaîne de caractères.
</span><span style="color:#75715e"></span>{
    <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> s;   <span style="color:#75715e">// Le pointeur sur la chaîne de caractères.
</span><span style="color:#75715e"></span> 
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    chaine(<span style="color:#66d9ef">void</span>);           <span style="color:#75715e">// Le constructeur par défaut.
</span><span style="color:#75715e"></span>    chaine(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span>);   <span style="color:#75715e">// Le constructeur. Il n&#39;a pas de type.
</span><span style="color:#75715e"></span>    <span style="color:#f92672">~</span>chaine(<span style="color:#66d9ef">void</span>);          <span style="color:#75715e">// Le destructeur.
</span><span style="color:#75715e"></span>};
 
chaine<span style="color:#f92672">::</span>chaine(<span style="color:#66d9ef">void</span>)
{
    s<span style="color:#f92672">=</span>NULL;                 <span style="color:#75715e">// La chaîne est initialisée avec
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> ;                <span style="color:#75715e">// le pointeur nul.
</span><span style="color:#75715e"></span>}
 
chaine<span style="color:#f92672">::</span>chaine(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> Taille)
{
    s <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">char</span>[Taille<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]; <span style="color:#75715e">// Alloue de la mémoire pour la chaîne.
</span><span style="color:#75715e"></span>    s[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;\0&#39;</span>;              <span style="color:#75715e">// Initialise la chaîne à &#34;&#34;.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span>;
}
 
chaine<span style="color:#f92672">::~</span>chaine(<span style="color:#66d9ef">void</span>)
{
    <span style="color:#66d9ef">if</span> (s<span style="color:#f92672">!=</span>NULL) <span style="color:#66d9ef">delete</span>[] s; <span style="color:#75715e">// Restitue la mémoire utilisée si
</span><span style="color:#75715e"></span>                             <span style="color:#75715e">// nécessaire.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span>;
}
</code></pre></div><p>Pour passer les paramètres au constructeur, on donne la liste des paramètres
entre parenthèses juste après le nom de l&rsquo;objet lors de son instanciation :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">chaine s1;        <span style="color:#75715e">// Instancie une chaîne de caractères
</span><span style="color:#75715e"></span>                  <span style="color:#75715e">// non initialisée.
</span><span style="color:#75715e"></span>chaine <span style="color:#a6e22e">s2</span>(<span style="color:#ae81ff">200</span>);   <span style="color:#75715e">// Instancie une chaîne de caractères
</span><span style="color:#75715e"></span>                  <span style="color:#75715e">// de 200 caractères.
</span></code></pre></div><p>Les constructeurs devront parfois effectuer des tâches plus compliquées que
celles données dans cet exemple. En général, ils peuvent faire toutes les
opérations faisables dans une méthode normale, sauf utiliser les données non
initialisées bien entendu. En particulier, les données des sous-objets d&rsquo;un
objet ne sont pas initialisées tant que les constructeurs des classes de base ne
sont pas appelés. C&rsquo;est pour cela qu&rsquo;il faut toujours appeler les constructeurs
des classes de base avant d&rsquo;exécuter le constructeur de la classe en cours
d&rsquo;instanciation. Si les constructeurs des classes de base ne sont pas appelés
explicitement, le compilateur appellera, par défaut, les constructeurs des
classes mères qui ne prennent pas de paramètre ou dont tous les paramètres ont
une valeur par défaut.</p>
<p>Comment appeler les constructeurs et les destructeurs des classes mères lors de
l&rsquo;instanciation et de la destruction d&rsquo;une classe dérivée ? Le compilateur ne
peut en effet pas savoir quel constructeur il faut appeler parmi les différents
constructeurs surchargés potentiellement présents &hellip; Pour appeler un autre
constructeur d&rsquo;une classe de base que le constructeur ne prenant pas de
paramètre, il faut spécifier explicitement ce constructeur avec ses paramètres
après le nom du constructeur de la classe fille, en les séparant de deux points.</p>
<p>En revanche, il est inutile de préciser le destructeur à appeler, puisque
celui-ci est unique. Le programmeur ne doit donc pas appeler lui-même les
destructeurs des classes mères, le langage s&rsquo;en charge.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">/* Déclaration de la classe mère. */</span>
 
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Mere</span>
{
    <span style="color:#66d9ef">int</span> m_i;
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Mere(<span style="color:#66d9ef">int</span>);
    <span style="color:#f92672">~</span>Mere(<span style="color:#66d9ef">void</span>);
};
 
<span style="color:#75715e">/* Définition du constructeur de la classe mère. */</span>
 
Mere<span style="color:#f92672">::</span>Mere(<span style="color:#66d9ef">int</span> i)
{
    m_i<span style="color:#f92672">=</span>i;
    printf(<span style="color:#e6db74">&#34;Exécution du constructeur de la classe mère.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    <span style="color:#66d9ef">return</span>;
}
 
<span style="color:#75715e">/* Définition du destructeur de la classe mère. */</span>
 
Mere<span style="color:#f92672">::~</span>Mere(<span style="color:#66d9ef">void</span>)
{
    printf(<span style="color:#e6db74">&#34;Exécution du destructeur de la classe mère.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    <span style="color:#66d9ef">return</span>;
}
 
<span style="color:#75715e">/* Déclaration de la classe fille. */</span>
 
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Fille</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Mere
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Fille(<span style="color:#66d9ef">void</span>);
    <span style="color:#f92672">~</span>Fille(<span style="color:#66d9ef">void</span>);
};
 
<span style="color:#75715e">/* Définition du constructeur de la classe fille
</span><span style="color:#75715e">   avec appel du constructeur de la classe mère. */</span>
 
Fille<span style="color:#f92672">::</span>Fille(<span style="color:#66d9ef">void</span>) <span style="color:#f92672">:</span> Mere(<span style="color:#ae81ff">2</span>)
{
    printf(<span style="color:#e6db74">&#34;Exécution du constructeur de la classe fille.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    <span style="color:#66d9ef">return</span>;
}
 
<span style="color:#75715e">/* Définition du destructeur de la classe fille
</span><span style="color:#75715e">   avec appel automatique du destructeur de la classe mère. */</span>
 
Fille<span style="color:#f92672">::~</span>Fille(<span style="color:#66d9ef">void</span>)
{
    printf(<span style="color:#e6db74">&#34;Exécution du destructeur de la classe fille.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    <span style="color:#66d9ef">return</span>;
}
</code></pre></div><p>Lors de l&rsquo;instanciation d&rsquo;un objet de la classe fille, le programme affichera
dans l&rsquo;ordre les messages suivants :</p>
<ol>
<li>Exécution du constructeur de la classe mère</li>
<li>Exécution du constructeur de la classe fille</li>
</ol>
<p>et lors de la destruction de l&rsquo;objet</p>
<ol>
<li>Exécution du destructeur de la classe fille</li>
<li>Exécution du destructeur de la classe mère</li>
</ol>
<p>Si l&rsquo;on n&rsquo;avait pas précisé que le constructeur à appeler pour la classe Mère
était le constructeur prenant un entier en paramètre, le compilateur aurait
essayé d&rsquo;appeler le constructeur par défaut de cette classe. Or, ce constructeur
n&rsquo;étant plus généré automatiquement par le compilateur (à cause de la définition
d&rsquo;un constructeur prenant un paramètre), il y aurait eu une erreur de
compilation.</p>
<p>Il est possible d&rsquo;appeler plusieurs constructeurs si la classé dérive de
plusieurs classes de base. Pour cela, il suffit de lister les constructeurs un à
un, en séparant leurs appels par des virgules. On notera cependant que l&rsquo;ordre
dans lequel les constructeurs sont appelés n&rsquo;est pas forcément l&rsquo;ordre dans
lequel ils sont listés dans la définition du constructeur de la classe fille. En
effet, le C++ appelle toujours les constructeurs dans l&rsquo;ordre d&rsquo;apparition de
leurs classes dans la liste des classes de base de la classe dérivée.</p>
<blockquote>
<p>Une fonction virtuelle peut donc toujours être appelée dans un constructeur,
mais la fonction effectivement appelée est celle de la classe du sous-objet en
cours de construction : pas celle de la classe de l&rsquo;objet complet. Ainsi, si
une classe A hérite d&rsquo;une classe B et qu&rsquo;elles ont toutes les deux une
fonction virtuelle f, l&rsquo;appel de f dans le constructeur de B utilisera la
fonction f de B, pas celle de A (même si l&rsquo;objet que l&rsquo;on instancie est de
classe A).</p>
</blockquote>
<p>La syntaxe utilisée pour appeler les constructeurs des classes de base peut
également être utilisée pour initialiser les données membres de la classe. En
particulier, cette syntaxe est obligatoire pour les données membres constantes
et pour les références, car le C++ ne permet pas l&rsquo;affectation d&rsquo;une valeur à
des variables de ce type. Encore une fois, l&rsquo;ordre d&rsquo;appel des constructeurs des
données membres ainsi initialisées n&rsquo;est pas forcément l&rsquo;ordre dans lequel ils
sont listés dans le constructeur de classe. En effet, le C++ utilise cette fois
l&rsquo;ordre de déclaration de chaque donnée membre.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">tableau</span>
{
    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> m_iTailleMax;
    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>m_pDonnees;
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    tableau(<span style="color:#66d9ef">int</span> iTailleMax);
    <span style="color:#f92672">~</span>tableau();
};
 
tableau<span style="color:#f92672">::</span>tableau(<span style="color:#66d9ef">int</span> iTailleMax) <span style="color:#f92672">:</span>
    m_iTailleMax(iTailleMax)    <span style="color:#75715e">// Initialise la donnée membre constante.
</span><span style="color:#75715e"></span>{
    <span style="color:#75715e">// Allocation d&#39;un tableau de m_iTailleMax entrées :
</span><span style="color:#75715e"></span>    m_pDonnees <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[m_iTailleMax];
}
 
tableau<span style="color:#f92672">::~</span>tableau()
{
    <span style="color:#75715e">// Destruction des données :
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">delete</span>[] m_pDonnees;
}
</code></pre></div><h3 id="constructeurs-de-copie">Constructeurs de copie</h3>
<p>Il faudra parfois créer un constructeur de copie. Le but de ce type de
constructeur est d&rsquo;initialiser un objet lors de son instanciation à partir d&rsquo;un
autre objet. Toute classe dispose d&rsquo;un constructeur de copie par défaut généré
automatiquement par le compilateur, dont le seul but est de recopier les champs
de l&rsquo;objet à recopier un à un dans les champs de l&rsquo;objet à instancier.
Toutefois, ce constructeur par défaut ne suffira pas toujours, et le programmeur
devra parfois en fournir un explicitement.</p>
<p>Ce sera notamment le cas lorsque certaines données des objets auront été
allouées dynamiquement. Une copie brutale des champs d&rsquo;un objet dans un autre ne
ferait que recopier les pointeurs, pas les données pointées. Ainsi, la
modification de ces données pour un objet entraînerait la modification des
données de l&rsquo;autre objet, ce qui ne serait sans doute pas l&rsquo;effet désiré.</p>
<p>La définition des constructeurs de copie se fait comme celle des constructeurs
normaux. Le nom doit être celui de la classe, et il ne doit y avoir aucun type.
Dans la liste des paramètres cependant, il devra toujours y avoir une référence
sur l&rsquo;objet à copier.</p>
<p>Pour la classe chaine définie ci-dessus, il faut un constructeur de copie.
Celui-ci peut être déclaré de la façon suivante</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">chaine(<span style="color:#66d9ef">const</span> chaine <span style="color:#f92672">&amp;</span>Source);
</code></pre></div><p>où Source est l&rsquo;objet à copier. Si l&rsquo;on rajoute la donnée membre Taille dans la
déclaration de la classe, la définition de ce constructeur peut être :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">chaine<span style="color:#f92672">::</span>chaine(<span style="color:#66d9ef">const</span> chaine <span style="color:#f92672">&amp;</span>Source)
{
    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;                   <span style="color:#75715e">// Compteur de caractères.
</span><span style="color:#75715e"></span>    Taille <span style="color:#f92672">=</span> Source.Taille;
    s <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">char</span>[Taille <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];    <span style="color:#75715e">// Effectue l&#39;allocation.
</span><span style="color:#75715e"></span>    strcpy(s, Source.s);         <span style="color:#75715e">// Recopie la chaîne de caractères source.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span>;
}
</code></pre></div><p>Le constructeur de copie est appelé dans toute instanciation avec
initialisation, comme celles qui suivent</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">chaine <span style="color:#a6e22e">s2</span>(s1);
chainse s2 <span style="color:#f92672">=</span> s1;
</code></pre></div><p>Dans les deux exemples, c&rsquo;est le constructeur de copie qui est appelé. En
particulier, à la deuxième ligne, le constructeur normal n&rsquo;est pas appelé et
aucune affectation entre objets n&rsquo;a lieu.</p>
<h3 id="utilisation-des-constructeurs-dans-les-transtypages">Utilisation des constructeurs dans les transtypages</h3>
<p>Les constructeurs sont utilisés dans les conversions de type dans lesquelles le
type cible est celui de la classe du constructeur. Ces conversions peuvent être
soit implicites (dans une expression), soit explicite (à l&rsquo;aide d&rsquo;un
transtypage). Par défaut, les conversions implicites sont légales, pourvu qu&rsquo;il
existe un constructeur dont le premier paramètre a le même type que l&rsquo;objet
source. Par exemple, la classe Entier suivante :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Entier</span>
{
    <span style="color:#66d9ef">int</span> i;
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Entier(<span style="color:#66d9ef">int</span> j)
    {
        i<span style="color:#f92672">=</span>j;
        <span style="color:#66d9ef">return</span> ;
    }
};
</code></pre></div><p>dispose d&rsquo;un constructeur de transtypage pour les entiers. Les expressions</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>;
Entier e1, e2<span style="color:#f92672">=</span>j;
e1<span style="color:#f92672">=</span>j;
</code></pre></div><p>sont donc légales, la valeur entière située à la droite de l&rsquo;expression étant
convertie implicitement en un objet du type de la classe Entier.</p>
<p>Si, pour une raison quelconque, ce comportement n&rsquo;est pas souhaitable, on peut
forcer le compilateur à n&rsquo;accepter que les conversions explicites (à l&rsquo;aide de
transtypage). Pour cela, il suffit de placer le mot clé <code>explicit</code> avant la
déclaration du constructeur. Par exemple, le constructeur de la classe chaine
vue ci-dessus prenant un entier en paramètre risque d&rsquo;être utilisé dans des
conversions implicites. Or ce constructeur ne permet pas de construire une
chaîne de caractères à partir d&rsquo;un entier, et ne doit pas être utilisé dans les
opérations de transtypage. Ce constructeur doit donc être déclaré <code>explicit</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">chaine</span>
{
    size_t Taille;
    <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> s;
 
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    chaine(<span style="color:#66d9ef">void</span>);
    <span style="color:#75715e">// Ce constructeur permet de préciser la taille de la chaîne
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// à sa création :
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">explicit</span> <span style="color:#a6e22e">chaine</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span>);
    <span style="color:#f92672">~</span>chaine(<span style="color:#66d9ef">void</span>);
};
</code></pre></div><p>Avec cette déclaration, l&rsquo;expression suivante</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>;
chainse s<span style="color:#f92672">=</span>j;
</code></pre></div><p>n&rsquo;est plus valide, alors qu&rsquo;elle l&rsquo;était lorsque le constructeur n&rsquo;était pas
explicit.</p>
<h2 id="pointeur-this">Pointeur <code>this</code></h2>
<p>Nous allons à présent voir comment les fonctions membres, qui appartiennent à la
classe, peuvent accéder aux données d&rsquo;un objet, qui est une instance de cette
classe. Cela est indispensable pour bien comprendre les paragraphes suivants.</p>
<p>À chaque appel d&rsquo;une fonction membre, le compilateur passe implicitement un
pointeur sur les données de l&rsquo;objet en paramètre. Ce paramètre est le premier
paramètre de la fonction. Ce mécanisme est complètement invisible au programmeur,
et nous ne nous attarderons pas dessus.</p>
<p>En revanche, in faut savoir que le pointeur sur l&rsquo;objet est accessible à
l&rsquo;intérieur de la fonction membre. Il porte le nom <code>this</code>. Par conséquent,
<code>*this</code> représente l&rsquo;objet lui-même. Nous verrons une utilisation de <code>this</code> dans
le paragraphe suivant</p>
<p><code>this</code> est un pointeur constant, c&rsquo;est à dire qu&rsquo;on ne peut pas le modifier (il
est donc impossible de faire des opérations arithmétiques dessus). Cela est tout
à fait normal, puisque le faire reviendrait à sortir de l&rsquo;objet en cours (celui
pour lequel la méthode en cours d&rsquo;exécution travaille).</p>
<p>Il est possible de transformer ce pointeur constant en un pointeur constant sur
des données constantes pour chaque fonction membre. Le pointeur ne peut toujours
pas être modifié, et les données de l&rsquo;objet ne peuvent pas être modifiées non
plus. L&rsquo;objet est donc considéré par la fonction membre concernée comme un objet
constant. Cela revient à dire que la fonction membre s&rsquo;interdit la modification
des données de l&rsquo;objet. On parvient à ce résultat en ajoutant le mot clé <code>const</code>
à la suite de l&rsquo;en te de la fonction membre.</p>
<p>Il est à noter qu&rsquo;une méthode qui n&rsquo;est pas déclarée comme étant <code>const</code> modifie
a priori les données de l&rsquo;objet sur lequel elle travaille. Donc, si elle est
appelée sur un objet déclaré <code>const</code>, une erreur de compilation se produit. Ce
comportement est normal. On devra donc toujours déclarer <code>const</code> une méthode qui
ne modifie pas réellement l&rsquo;objet, afin de laisse à l&rsquo;utilisateur le choix de
déclarer <code>const</code> ou non les objets de sa classe.</p>
<h2 id="données-et-fonctions-membres-statiques">Données et fonctions membres statiques</h2>
<p>Nous allons voir dans ce paragraphe l&rsquo;emploi du mot clé <code>static</code> dans les
classes. Ce mot clé intervient pour caractériser les données membres statiques
des classes, les fonctions membres statiques des classes, et les données
statiques des fonctions membres.</p>
<h3 id="données-membres-statiques">Données membres statiques</h3>
<p>Une classe peut contenir des données membres statiques. Ces données sont soit
des données membres propres à la classe, soit des données locales statiques des
fonctions membres de la classe. Dans tous les cas, elles appartiennent à la
classe, et non pas aux objets de cette classe. Elles sont donc communes à tous
ces objets.</p>
<p>Il est impossible d&rsquo;initialiser les données d&rsquo;une classe dans le constructeur de
la classe, car le constructeur n&rsquo;initialise que les données des nouveaux objets.
Les données statiques ne sont pas spécifiques à un objet particulier et ne
peuvent donc pas être initialisées dans le constructeur. En fait, leur
initialisation doit se faire lors de leur définition, en dehors de la
déclaration de la classe. Pour préciser la classe à laquelle les données sont
définies appartiennent, on devra utiliser l&rsquo;opérateur de résolution de portée.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">test</span>
{
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> i;       <span style="color:#75715e">// Déclaration dans la classe.
</span><span style="color:#75715e"></span>    ...
};
 
<span style="color:#66d9ef">int</span> test<span style="color:#f92672">::</span>i<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>;         <span style="color:#75715e">// Initialisation en dehors de la classe.
</span></code></pre></div><p>La variable <code>test::i</code> sera partagée par tous les objets de classe test, et sa
valeur initiale est 3.</p>
<p>Les variables statiques des fonctions membres doivent être initialisées à
l&rsquo;intérieur des fonctions membres. Elles appartiennent également à la classe, et
non pas aux objets. De plus, leur portée est réduite à celle du bloc dans lequel
elles ont été déclarées. Ainsi le code suivante :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span> 
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">test</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> n(<span style="color:#66d9ef">void</span>);
};
 
<span style="color:#66d9ef">int</span> test<span style="color:#f92672">::</span>n(<span style="color:#66d9ef">void</span>)
{
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> compte<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">return</span> compte<span style="color:#f92672">++</span>;
}
 
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>)
{
    test objet1, objet2;
    printf(<span style="color:#e6db74">&#34;%d &#34;</span>, objet1.n());   <span style="color:#75715e">// Affiche 0
</span><span style="color:#75715e"></span>    printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, objet2.n());  <span style="color:#75715e">// Affiche 1
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>affichera 0 et 1, parque la variable statique compte est la même pour les deux
objets</p>
<h3 id="fonctions-membres-statiques">Fonctions membres statiques</h3>
<p>Les classes peuvent également contenir des fonctions membres statiques. Cela
peut surprendre à première vue, puisque les fonctions membres appartiennent déjà
à la classe, c&rsquo;est à dire à tous les objets. En fait, cela signifie que ces
fonctions membres ne recevront pas le pointeur sur l&rsquo;objet <code>this</code>, comme c&rsquo;est
le cas pour les autres fonctions membres. Par conséquent, elles ne pourront
accéder qu&rsquo;aux données statiques de l&rsquo;objet</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Entier</span>
{
    <span style="color:#66d9ef">int</span> i;
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> j;
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> get_value(<span style="color:#66d9ef">void</span>);
};
 
<span style="color:#66d9ef">int</span> Entier<span style="color:#f92672">::</span>j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
 
<span style="color:#66d9ef">int</span> Entier<span style="color:#f92672">::</span>get_value(<span style="color:#66d9ef">void</span>)
{
    j<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;         <span style="color:#75715e">// Légal.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> i;    <span style="color:#75715e">// ERREUR ! get_value ne peut pas accéder à i.
</span><span style="color:#75715e"></span>}
</code></pre></div><p>La fonction <code>get_value</code> de l&rsquo;exemple ci-dessus ne peut pas accéder à la donnée
membre non statique <code>i</code>, parce qu&rsquo;elle ne travaille sur aucun objet. Son champ
d&rsquo;action est uniquement la classe Entier. En revanche, elle peut modifier la
variable statique <code>j</code>, puisque celle-ci appartient à la classe Entier et non aux
objets de cette classe.</p>
<p>L&rsquo;appel des fonctions membre statiques se fait exactement comme celui des
fonctions membres non statiques, en spécifiant l&rsquo;identificateur d&rsquo;un des objets
de la classe et le nom de la fonction membre, séparés par un point. Cependant,
comme les fonctions membres ne travaillent pas sur les objets des classes mais
plutôt sur les classes elles-mêmes, la présence de l&rsquo;objet lors de l&rsquo;appel est
facultatif. On peut donc se contenter d&rsquo;appeler une fonction statique en
qualifiant son nom du nom de la classe à laquelle elle appartient à l&rsquo;aide de
l&rsquo;opérateur de résolution de portée.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Entier</span>
{
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> i;
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> get_value(<span style="color:#66d9ef">void</span>);
};
 
<span style="color:#66d9ef">int</span> Entier<span style="color:#f92672">::</span>i<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>;
 
<span style="color:#66d9ef">int</span> Entier<span style="color:#f92672">::</span>get_value(<span style="color:#66d9ef">void</span>)
{
    <span style="color:#66d9ef">return</span> i;
}
 
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>)
{
    <span style="color:#75715e">// Appelle la fonction statique get_value :
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> resultat<span style="color:#f92672">=</span>Entier<span style="color:#f92672">::</span>get_value();
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>Les fonctions membres statiques sont souvent utilisées afin de regrouper un
certain nombre de fonctionnalités en rapport avec leur classe. Ainsi, elles sont
facilement localisable et les risques de conflits de noms entre deux fonctions
membres homonymes sont réduits. Nous verrons également plus tard comment éviter
les conflits de noms globaux dans le cadre des espaces de nommage.</p>
<h2 id="surcharge-des-opérateurs">Surcharge des opérateurs</h2>
<p>On a vu précédemment que les opérateurs ne se différencient des fonctions que
syntaxiquement, pas logiquement. D&rsquo;ailleurs, le compilateur traite un appel à un
opérateur comme un appel à une fonction. Le C++ permet donc de surcharger les
opérateurs pour les classes définies par l&rsquo;utilisateur, en utilisant une
syntaxe particulière calquée sur la syntaxe utilisée pour définir des fonctions
membres normales. En fait, il est même possible de surcharger les opérateurs du
langage pour les classes de l&rsquo;utilisateur en dehors de la définition de ces
classes. Le C++ dispose donc de deux méthodes différentes pour surcharger les
opérateurs.</p>
<p>Nous allons à présent voir dans les sections suivantes les deux syntaxes
permettant de surcharger les opérateurs pour les types de l&rsquo;utilisateur, ainsi
que les règles spécifiques à certains opérateurs particuliers.</p>
<h3 id="surcharge-des-opérateurs-internes">Surcharge des opérateurs internes</h3>
<p>Une première méthode pour surcharger les opérateurs consiste à les considérer
comme des méthodes normales de la classe sur laquelle ils s&rsquo;appliquent. Le nom
de ces méthodes est donné par le mot clé <code>operator</code>, suivi de l&rsquo;opérateur à
surcharger. Le type de la fonction de l&rsquo;opérateur est le type du résultat donné
par l&rsquo;opération, et les paramètres, donnés entre parenthèses, sont les
opérandes. Les opérateurs de ce type sont appelés opérateurs internes, parce
qu&rsquo;ils sont déclarés à l&rsquo;intérieur de la classe.</p>
<p>Avec cette syntaxe, le premier opérande est toujours l&rsquo;objet auquel cette
fonction s&rsquo;applique. Cette manière de surcharger les opérateurs est donc
particulièrement bien adaptée pour les opérateurs qui modifient l&rsquo;objet sur
lequel ils travaillent, comme par exemple ,es opérateurs =, +=, ++, etc. Les
paramètres de la fonction opérateur sont alors le deuxième opérande et les
suivants.</p>
<p>Les opérateurs définis en interne devront souvent renvoyer l&rsquo;objet sur lequel
ils travaillent (ce n&rsquo;est pas une nécessité cependant). Cela est faisable grâce
au pointeur <code>this</code>.</p>
<h3 id="surcharge-des-opérateurs-externes">Surcharge des opérateurs externes</h3>
<p>Une deuxième possibilité nous est offerte par le langage pour surcharger les
opérateurs. La définition de l&rsquo;opérateur ne se fait plus dans la classe qui
l&rsquo;utilise, mais en dehors de celle-ci, par surcharge d&rsquo;un opérateur de l&rsquo;espace
de nommage global. Il s&rsquo;agit donc d&rsquo;opérateurs externes cette fois.</p>
<p>La surcharge des opérateurs externes se fait donc exactement comme on surcharge
les fonctions normales. Dans ce cas, tous les opérandes de l&rsquo;opérateur devront
être passés en paramètres : il n&rsquo;y aura pas de paramètre implicite (le pointeur
<code>this</code> n&rsquo;est pas passé en paramètre).</p>
<p>L&rsquo;avantage de cette syntaxe est que l&rsquo;opérateur est réellement symétrique,
contrairement à ce qui se passe pour ces opérateurs définis à l&rsquo;intérieur de la
classe. Ainsi, si l&rsquo;utilisation de cet opérateur nécessite un transtypage sur
l&rsquo;un des opérandes, il n&rsquo;est pas nécessaire que cet opérande soit
obligatoirement le deuxième. Donc si la classe dispose de constructeurs
permettant de convertir un type de donnée en son propre type, ce type de donnée
peut être utilisé avec tous les opérateurs de la classe.</p>
<p>On constatera que les opérateurs externes doivent être déclarés comme étant des
fonctions amies de la classe sur laquelle ils travaillent, faut de quoi ils ne
pourraient pas manipuler les données membres de leurs opérandes.</p>
<p>La syntaxe des opérateurs externes permet également d&rsquo;implémenter les opérateurs
pour lesquels le type de la valeur de retour est celui de l&rsquo;opérande de gauche
et que le type de cet opérande n&rsquo;est pas une classe définie par l&rsquo;utilisateur
(par exemple si c&rsquo;est un type prédéfini). En effet, on ne peut pas définir
l&rsquo;opérateur à l&rsquo;intérieur de la classe du premier opérande dans ce cas, puisque
cette classe est déjà définie. De même, cette syntaxe peut être utile dans le
cas de l&rsquo;écriture d&rsquo;opérateurs optimisés pour certains types de données, pour
lesquels les opérations réalisées par l&rsquo;opérateur sont plus simples que celles
qui auraient été effectuées après transtypage.</p>
<h3 id="opérateurs-daffectation">Opérateurs d&rsquo;affectation</h3>
<p>Nous avons déjà vu un exemple d&rsquo;opérateur d&rsquo;affectation avec la classe complexe
ci-dessus. Cet opérateur était très simple, mais ce n&rsquo;est généralement pas
toujours le cas, et l&rsquo;implémentation des opérateurs d&rsquo;affectation peut parfois
soulever quelques problèmes.</p>
<p>Premièrement, comme nous l&rsquo;avons dit plus tôt, le fait de définir un opération
d&rsquo;affectation signale souvent que la classe n&rsquo;a pas une structure simple et que,
par conséquent, le constructeur de copie et le destructeur fournis par défaut
par le compilateur ne suffisent pas. Il faut donc veiller à respecter la règle
des trois, qui stipule que si l&rsquo;une de ces méthodes est redéfinie, il faut que
les trois le soient. Par exemple, si vous ne redéfinissez pas le constructeur de
copie, les écritures telles que <code>classe object = source;</code> ne fonctionnement pas
correctement. En effet, c&rsquo;est le constructeur de copie qui est appelé ici, et
non l&rsquo;opérateur d&rsquo;affectation comme on pourrait le penser à première vue. De
même, les traitements particuliers effectués lors de la copie ou de
l&rsquo;initialisation d&rsquo;un objet devront être effectués en ordre inverse dans le
destructeur de l&rsquo;objet. Les traitements de destruction consistent généralement à
libérer la mémoire et toutes les ressources allouées dynamiquement.</p>
<p>Lorsque l&rsquo;on écrit un opérateur d&rsquo;affectation, on a généralement à reproduire, à
peu de choses près, le même code que celui qui se trouve dans le constructeur de
copie. Il arrive même parfois que l&rsquo;on doive libérer les ressources existantes
avant de faire l&rsquo;affectation, et donc le code de l&rsquo;opérateur d&rsquo;affectation
ressemble souvent à la concaténation du code du destructeur et du code du
constructeur de copie. Bien entendu, cette duplication de code est gênante et
peu élégante. Une solution simple est d&rsquo;implémenter une fonction de duplication
et une fonction de libération des données. Ces deux fonctions, par exemple reset
et clone, pourront être utilisées dans le destructeur, le constructeur de copie
et l&rsquo;opérateur d&rsquo;affectation. Le programme devient ainsi beaucoup plus simple.
Il ne faut généralement pas utiliser l&rsquo;opérateur d&rsquo;affectation dans le
constructeur de copie, car cela peut poser des problèmes complexes à résoudre.
Par exemple, il faut s&rsquo;assurer que l&rsquo;opérateur de copie ne cherche pas à
utiliser des données membres non initialisées lors de son appel.</p>
<p>Un autre problème important est celui de l&rsquo;autoaffectation. Non seulement
affecter un objet à lui-même est inutile et consommateur de ressources, mais en
plus cela peut être dangereux. En effet, l&rsquo;affectation risque de détruire les
données membres de l&rsquo;objet avant même qu&rsquo;elles ne soient copiées, ce qui
provoquerait en fin de compte simplement la destruction de l&rsquo;objet ! Une
solution simple consiste ici à ajouter un test sur l&rsquo;objet source en début
d&rsquo;opérateur, comme dans l&rsquo;exemple suivant</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">classe <span style="color:#f92672">&amp;</span>classe<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> classe <span style="color:#f92672">&amp;</span>source)
{
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">&amp;</span>source <span style="color:#f92672">!=</span> <span style="color:#66d9ef">this</span>)
    {
        <span style="color:#75715e">// Traitement de copie des données :
</span><span style="color:#75715e"></span>        ...
    }
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
}
</code></pre></div><p>Enfin, la copie des données peut lancer une exception et laisser l&rsquo;objet sur
lequel l&rsquo;affectation se fait dans un état indéterminé. La solution la plus
simple dans ce cas est encore de construire une copie de l&rsquo;objet source en
local, puis d&rsquo;échanger le contenu des données de l&rsquo;objet avec cette copie.
Ainsi, si la copie échoue pour une raison ou une autre, l&rsquo;objet source n&rsquo;est pas
modifié et reste dans un état stable. Le pseudo-code permettant de réaliser ceci
est le suivant :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">classe <span style="color:#f92672">&amp;</span>classe<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> classe <span style="color:#f92672">&amp;</span>source)
{
    <span style="color:#75715e">// Construit une copie temporaire de la source :
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Temp</span>(source);
    <span style="color:#75715e">// Échange le contenu de cette copie avec l&#39;objet courant :
</span><span style="color:#75715e"></span>    swap(Temp, <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>);
    <span style="color:#75715e">// Renvoie l&#39;objet courant (modifié) et détruit les données
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// de la variable temporaire (contenant les anciennes données) :
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
}
</code></pre></div><h3 id="opérateurs-de-transtypage">Opérateurs de transtypage</h3>
<p>Nous avons vu précédemment que les constructeurs peuvent être utilisés pour
convertir des objets du type de leur paramètre vers le type de leur classe. Ces
conversions peuvent avoir lieu de manière implicite ou non, selon que le mot clé
<code>explicit</code> est appliqué au constructeur en question.</p>
<p>Cependant, il n&rsquo;est pas toujours faisable d&rsquo;écrire un tel constructeur. Par
exemple, la classe cible peut parfaitement être une des classes de la
bibliothèque standard, dont on ne doit évidemment pas modifier les fichiers
source, ou même un des types de base du langage, pour lequel il n&rsquo;y a pas de
définition. Heureusement, les conversions peuvent malgré tout être réalisées
dans ce cas, simplement en surchargeant les opérateurs de transtypage.</p>
<p>Prenons l&rsquo;exemple de la classe chaine, qui permet de faire des chaînes de
caractères dynamiques (de longueur variable). Il est possible de les convertir
en chaîne C classiques (c&rsquo;est à dire en tableau de caractères) si l&rsquo;opérateur
(<code>char const *</code>) a été surchargé</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">chaine<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">char</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">*</span>(<span style="color:#66d9ef">void</span>) <span style="color:#66d9ef">const</span>;
</code></pre></div><p>On constate que cet opérateur n&rsquo;attend aucun paramètre, puisqu&rsquo;il s&rsquo;applique à
tout l&rsquo;objet qui l&rsquo;appelle, mais surtout il n&rsquo;a pas de type. En effet, puisque
c&rsquo;est un opérateur de transtypage, son type est nécessairement celui qui lui
correspond (dans le cas présent, <code>char const *</code>).</p>
<h3 id="opérateurs-de-comparaison">Opérateurs de comparaison</h3>
<p>Les opérateurs de comparaison sont très simples à surcharger. La seule chose
essentielle à retenir est qu&rsquo;ils renvoient une valeur booléenne. Ainsi, pour la
classe chaine, on peut déclarer les opérateurs d&rsquo;égalité et d&rsquo;infériorité (dans
l&rsquo;ordre lexicographique par exemple) de deux chaînes de caractères comme suit</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">bool</span> chaine<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">==</span>(<span style="color:#66d9ef">const</span> chaine <span style="color:#f92672">&amp;</span>) <span style="color:#66d9ef">const</span>;
<span style="color:#66d9ef">bool</span> chaine<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">&lt;</span>(<span style="color:#66d9ef">const</span> chaine <span style="color:#f92672">&amp;</span>) <span style="color:#66d9ef">const</span>;
</code></pre></div><h3 id="opérateurs-dincrémentation-et-de-décrémentation">Opérateurs d&rsquo;incrémentation et de décrémentation</h3>
<p>Les opérateurs d&rsquo;incrémentation et de décrémentation sont tous les deux doubles,
c&rsquo;est à dire que la même notation représente deux opérateurs en réalité. En
effet, ils n&rsquo;ont pas la même signification, selon qu&rsquo;ils sont placés avant ou
après leur opérande. Le problème est que comme ces opérateurs ne prennent pas de
paramètres (ils ne travaillent que sur l&rsquo;objet), il est impossible de les
différencier par surcharge. La solution qui a été adoptée est de les
différencier en donnant un paramètre fictif de type <code>int</code> à l&rsquo;un d&rsquo;entre eux.
Ainsi les opérateurs <code>++</code> et <code>--</code> ne prennent pas de paramètre lorsqu&rsquo;il s&rsquo;agit
des opérateurs préfixés, et ont un argument fictif (que l&rsquo;on ne doit pas
utiliser) lorsqu&rsquo;ils sont suffixés. Les versions préfixées des opérateurs
doivent renvoyer une référence sur l&rsquo;objet lui-même, les versions suffixées en
revanche peuvent se contenter de renvoyer la valeur de l&rsquo;objet.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Entier</span>
{
    <span style="color:#66d9ef">int</span> i;
 
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Entier(<span style="color:#66d9ef">int</span> j)
    {
        i<span style="color:#f92672">=</span>j;
        <span style="color:#66d9ef">return</span>;
    }
 
    Entier <span style="color:#66d9ef">operator</span><span style="color:#f92672">++</span>(<span style="color:#66d9ef">int</span>)   <span style="color:#75715e">// Opérateur suffixe :
</span><span style="color:#75715e"></span>    {                        <span style="color:#75715e">// retourne la valeur et incrémente
</span><span style="color:#75715e"></span>        Entier <span style="color:#a6e22e">tmp</span>(i);       <span style="color:#75715e">// la variable.
</span><span style="color:#75715e"></span>        <span style="color:#f92672">++</span>i;
        <span style="color:#66d9ef">return</span> tmp;
    }
 
    Entier <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">++</span>(<span style="color:#66d9ef">void</span>) <span style="color:#75715e">// Opérateur préfixe : incrémente
</span><span style="color:#75715e"></span>    {                        <span style="color:#75715e">// la variable et la retourne.
</span><span style="color:#75715e"></span>        <span style="color:#f92672">++</span>i;
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
    }
};
</code></pre></div><h3 id="opérateur-fonctionnel">Opérateur fonctionnel</h3>
<p>L&rsquo;opérateur d&rsquo;appel de fonctions peut également être surchargé. Cet opérateur
permet de réaliser des objets qui se comportent comme des fonctions (ce que l&rsquo;on
appelle foncteurs). La bibliothèque standard C++ en fait un usage intensif,
comme nous pourrons le constater dans la deuxième partie de ce document.</p>
<p>L&rsquo;opérateur fonctionnel est également très utilie en raison de son n-arité. Il
est donc utilisé couramment pour les classes de gestion de matrices de nombres,
afin d&rsquo;autoriser l&rsquo;écriture matrice(i,j,k)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">matrice</span>
{
    <span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">double</span> <span style="color:#f92672">*</span>ligne;
    ligne <span style="color:#f92672">*</span>lignes;
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">short</span> <span style="color:#66d9ef">int</span> n;   <span style="color:#75715e">// Nombre de lignes (1er paramètre).
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">short</span> <span style="color:#66d9ef">int</span> m;   <span style="color:#75715e">// Nombre de colonnes (2ème paramètre).
</span><span style="color:#75715e"></span> 
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    matrice(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">short</span> <span style="color:#66d9ef">int</span> nl, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">short</span> <span style="color:#66d9ef">int</span> nc);
    matrice(<span style="color:#66d9ef">const</span> matrice <span style="color:#f92672">&amp;</span>source);
    <span style="color:#f92672">~</span>matrice(<span style="color:#66d9ef">void</span>);
    matrice <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> matrice <span style="color:#f92672">&amp;</span>m1);
    <span style="color:#66d9ef">double</span> <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">operator</span>()(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">short</span> <span style="color:#66d9ef">int</span> i, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">short</span> <span style="color:#66d9ef">int</span> j);
    <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">operator</span>()(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">short</span> <span style="color:#66d9ef">int</span> i, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">short</span> <span style="color:#66d9ef">int</span> j) <span style="color:#66d9ef">const</span>;
};
 
<span style="color:#75715e">// Le constructeur :
</span><span style="color:#75715e"></span>matrice<span style="color:#f92672">::</span>matrice(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">short</span> <span style="color:#66d9ef">int</span> nl, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">short</span> <span style="color:#66d9ef">int</span> nc)
{
    n <span style="color:#f92672">=</span> nl;
    m <span style="color:#f92672">=</span> nc;
    lignes <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ligne[n];
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">short</span> <span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>n; <span style="color:#f92672">++</span>i)
        lignes[i] <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">double</span>[m];
    <span style="color:#66d9ef">return</span>;
}
 
<span style="color:#75715e">// Le constructeur de copie :
</span><span style="color:#75715e"></span>matrice<span style="color:#f92672">::</span>matrice(<span style="color:#66d9ef">const</span> matrice <span style="color:#f92672">&amp;</span>source)
{
    m <span style="color:#f92672">=</span> source.m;
    n <span style="color:#f92672">=</span> source.n;
    lignes <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ligne[n];   <span style="color:#75715e">// Alloue.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">short</span> <span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>n; <span style="color:#f92672">++</span>i)
    {
        lignes[i] <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">double</span>[m];
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">short</span> <span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; j<span style="color:#f92672">&lt;</span>m; <span style="color:#f92672">++</span>j)  <span style="color:#75715e">// Copie.
</span><span style="color:#75715e"></span>            lignes[i][j] <span style="color:#f92672">=</span> source.lignes[i][j];
    }
    <span style="color:#66d9ef">return</span>;
}
 
<span style="color:#75715e">// Le destructeur :
</span><span style="color:#75715e"></span>matrice<span style="color:#f92672">::~</span>matrice(<span style="color:#66d9ef">void</span>)
{
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">short</span> <span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>n; <span style="color:#f92672">++</span>i)
        <span style="color:#66d9ef">delete</span>[] lignes[i];
    <span style="color:#66d9ef">delete</span>[] lignes;
    <span style="color:#66d9ef">return</span>;
}
 
<span style="color:#75715e">// L&#39;opérateur d&#39;affectation :
</span><span style="color:#75715e"></span>matrice <span style="color:#f92672">&amp;</span>matrice<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> matrice <span style="color:#f92672">&amp;</span>source)
{
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">&amp;</span>source <span style="color:#f92672">!=</span> <span style="color:#66d9ef">this</span>)
    {
        <span style="color:#66d9ef">if</span> (source.n<span style="color:#f92672">!=</span>n <span style="color:#f92672">||</span> source.m<span style="color:#f92672">!=</span>m)   <span style="color:#75715e">// Vérifie les dimensions.
</span><span style="color:#75715e"></span>        {
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">short</span> <span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>n; <span style="color:#f92672">++</span>i)
                <span style="color:#66d9ef">delete</span>[] lignes[i];
            <span style="color:#66d9ef">delete</span>[] lignes;              <span style="color:#75715e">// Détruit...
</span><span style="color:#75715e"></span>            m <span style="color:#f92672">=</span> source.m;
            n <span style="color:#f92672">=</span> source.n;
            lignes <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ligne[n];        <span style="color:#75715e">// et réalloue.
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">for</span> (i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>n; <span style="color:#f92672">++</span>i) lignes[i] <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">double</span>[m];
        }
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">short</span> <span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>n; <span style="color:#f92672">++</span>i) <span style="color:#75715e">// Copie.
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">short</span> <span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; j<span style="color:#f92672">&lt;</span>m; <span style="color:#f92672">++</span>j)
                lignes[i][j] <span style="color:#f92672">=</span> source.lignes[i][j];
    }
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
}
 
<span style="color:#75715e">// Opérateurs d&#39;accès :
</span><span style="color:#75715e"></span><span style="color:#66d9ef">double</span> <span style="color:#f92672">&amp;</span>matrice<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span>()(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">short</span> <span style="color:#66d9ef">int</span> i,
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">short</span> <span style="color:#66d9ef">int</span> j)
{
    <span style="color:#66d9ef">return</span> lignes[i][j];
}
 
<span style="color:#66d9ef">double</span> matrice<span style="color:#f92672">::</span><span style="color:#66d9ef">operator</span>()(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">short</span> <span style="color:#66d9ef">int</span> i,
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">short</span> <span style="color:#66d9ef">int</span> j) <span style="color:#66d9ef">const</span>
{
    <span style="color:#66d9ef">return</span> lignes[i][j];
}
</code></pre></div><p>Ainsi, on pourra effectuer la déclaration d&rsquo;une matrice avec <code>matrice m(2,3);</code>
et accéder à ses éléments simplement avec <code>m(i,j)=6;</code>. On remarquera que l&rsquo;on a
défini deux opérateurs fonctionnels dans l&rsquo;exemple donné ci-dessus. Le premier
renvoie une référence et permet de modifier la valeur d&rsquo;un des éléments de la
matrice. Cet opérateur ne peut bien entendu pas s&rsquo;appliquer à une matrice
constante, même simplement pour lire un élément. C&rsquo;est donc le deuxième
opérateur qui sera utilisé pour lire les éléments des matrices constantes, car
il renvoie une valeur et non plus une référence. Le choix de l&rsquo;opérateur à
utiliser est déterminé par la présence du mot clé <code>const</code>, qui indique que seul
cet opérateur peut être utilisé pour une matrice constante.</p>
<h3 id="opérateurs-dindirection-et-de-déréférencement">Opérateurs d&rsquo;indirection et de déréférencement</h3>
<p>L&rsquo;opérateur de déréférencement * permet l&rsquo;écriture de classes dont les objets peuvent être utilisés dans des expressions manipulant des pointeurs. L&rsquo;opérateur d&rsquo;indirection &amp; quant à lui, permet de renvoyer une adresse autre que celle de l&rsquo;objet sur lequel il s&rsquo;applique. Enfin, l&rsquo;opérateur de déréférencement et de sélection de membres de structures -&gt; permet de réaliser des classes qui encapsulent d&rsquo;autres classes.</p>
<p>Si les opérateurs de déréférencement et d&rsquo;indirection &amp; et * peuvent renvoyer
une valeur de type quelconque, ce n&rsquo;est pas le cas de l&rsquo;opérateur de
déréférencement et de sélection de membre -&gt;. Cet opérateur doit nécessairement
renvoyer un type pour lequel il doit encore être applicable. Ce type doit donc
soit surcharger l&rsquo;opérateur -&gt;, soit être un pointeur sur une structure, union
ou classe.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// Cette classe est encapsulée par une autre classe :
</span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Encapsulee</span>
{
    <span style="color:#66d9ef">int</span> i;       <span style="color:#75715e">// Donnée à accéder.
</span><span style="color:#75715e"></span>};
 
Encapsulee o;    <span style="color:#75715e">// Objet à manipuler.
</span><span style="color:#75715e"></span> 
<span style="color:#75715e">// Cette classe est la classe encapsulante :
</span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Encapsulante</span>
{
    Encapsulee <span style="color:#f92672">*</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">-&gt;</span>(<span style="color:#66d9ef">void</span>) <span style="color:#66d9ef">const</span>
    {
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span>o;
    }
 
    Encapsulee <span style="color:#f92672">*</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">&amp;</span>(<span style="color:#66d9ef">void</span>) <span style="color:#66d9ef">const</span>
    {
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span>o;
    }
 
    Encapsulee <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">*</span>(<span style="color:#66d9ef">void</span>) <span style="color:#66d9ef">const</span>
    {
        <span style="color:#66d9ef">return</span> o;
    }
};
 
<span style="color:#75715e">// Exemple d&#39;utilisation :
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f</span>(<span style="color:#66d9ef">int</span> i)
{
    Encapsulante e;
    e<span style="color:#f92672">-&gt;</span>i<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>;         <span style="color:#75715e">// Enregistre 2 dans o.i.
</span><span style="color:#75715e"></span>    (<span style="color:#f92672">*</span>e).i <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;     <span style="color:#75715e">// Enregistre 3 dans o.i.
</span><span style="color:#75715e"></span>    Encapsulee <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>e;
    p<span style="color:#f92672">-&gt;</span>i <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;       <span style="color:#75715e">// Enregistre 4 dans o.i.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> ;
}
</code></pre></div><h3 id="opérateurs-dallocation-dynamique-de-mémoire">Opérateurs d&rsquo;allocation dynamique de mémoire</h3>
<p>Les opérateurs les plus difficiles à écrire sont sans doute les opérateurs d&rsquo;allocation dynamique de mémoire. Ces opérateurs prennent un nombre variable de paramètres, parce qu&rsquo;ils sont complètement surchargeables (c&rsquo;est à dire qu&rsquo;il est possible de définir plusieurs surcharges de ces opérateurs même au sein d&rsquo;une même classe, s&rsquo;ils sont définis de manière interne). Il est donc possible de définir plusieurs opérateurs new ou new[], et plusieurs opérateurs delete ou delete[]. Cependant, les premiers paramètres de ces opérateurs doivent toujours être la taille de la zone de la mémoire à allouer dans le cas des opérateurs new et new[], et le pointeur sur la zone de la mémoire à restituer dans le cas des opérateurs delete et delete[].</p>
<p>La forme la plus simple de new ne prend qu&rsquo;un paramètre : le nombre d&rsquo;octets à allouer, qui vaut toujours la taille de l&rsquo;objet à construire. Il doit renvoyer un pointeur du type void. L&rsquo;opérateur delete correspondant peut prendre, quant à lui, soit un, soit deux paramètres. Comme on l&rsquo;a déjà dit, le premier paramètre est toujours un pointeur du type void sur l&rsquo;objet à détruire. Le deuxième paramètre, s&rsquo;il existe, est du type size_t et contient la taille de l&rsquo;objet à détruire. Les mêmes règles s&rsquo;appliquent pour les opérateurs new[] et delete[], utilisés pour les tableaux.</p>
<p>Lorsque les opérateurs delete et delete[] prennent deux paramètres, le deuxième paramètre est la taille de la zone de la mémoire à restituer. Cela signifie que le compilateur se charge de mémoriser cette information. Pour les opérateurs new et delete, cela ne cause pas de problème, puisque la taille de cette zone est fixée par le type de l&rsquo;objet. En revanche, pour les tableaux, la taille du tableau doit être stockée avec le tableau. En général, le compilateur utilise un en-tête devant le tableau d&rsquo;objets. C&rsquo;est pour cela que la taille à allouer passée à new[], qui est la même que la taille à désallouer passée en paramètre à delete[], n&rsquo;est pas égale à la taille d&rsquo;un objet multipliée par le nombre d&rsquo;objets du tableau. Le compilateur demande un peu plus de mémoire, pour mémoriser la taille du tableau. On ne peut donc pas, dans ce cas, faire d&rsquo;hypothèses quant à la structure que le compilateur donnera à la mémoire allouée pour stocker le tableau.</p>
<p>En revanche, si delete[] ne prend en paramètre que le pointeur sur le tableau,
la mémorisation de la taille du tableau est à la charge du programmeur. Dans ce
cas, le compilateur donne à new[] la valeur exacte de la taille du tableau, à
savoir la taille d&rsquo;un objet multipliée par le nombre d&rsquo;objets dans le tableau.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span> 
<span style="color:#66d9ef">int</span> buffer[<span style="color:#ae81ff">256</span>];     <span style="color:#75715e">// Buffer servant à stocker le tableau.
</span><span style="color:#75715e"></span> 
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Temp</span>
{
    <span style="color:#66d9ef">char</span> i[<span style="color:#ae81ff">13</span>];      <span style="color:#75715e">// sizeof(Temp) doit être premier.
</span><span style="color:#75715e"></span> 
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">new</span>[](size_t taille)
    {
       <span style="color:#66d9ef">return</span> buffer;
    }
 
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">delete</span>[](<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>p, size_t taille)
    {
       printf(<span style="color:#e6db74">&#34;Taille de l&#39;en-tête : %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,
           taille<span style="color:#f92672">-</span>(taille<span style="color:#f92672">/</span><span style="color:#66d9ef">sizeof</span>(Temp))<span style="color:#f92672">*</span><span style="color:#66d9ef">sizeof</span>(Temp));
       <span style="color:#66d9ef">return</span> ;
    }
};
 
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>)
{
    <span style="color:#66d9ef">delete</span>[] <span style="color:#66d9ef">new</span> Temp[<span style="color:#ae81ff">1</span>];
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>Il est à noter qu&rsquo;aucun des opérateurs new, delete, new[] et delete[] ne reçoit le pointeur this en paramètre : ce sont des opérateurs statiques. Cela est normal puisque, lorsqu&rsquo;ils s&rsquo;exécutent, soit l&rsquo;objet n&rsquo;est pas encore créé, soit il est déjà détruit. Le pointeur this n&rsquo;existe donc pas encore (ou n&rsquo;est plus valide) lors de l&rsquo;appel de ces opérateurs.</p>
<p>Les opérateurs new et new[] peuvent avoir une forme encore un peu plus compliquée, qui permet de leur passer des paramètres lors de l&rsquo;allocation de la mémoire. Les paramètres supplémentaires doivent impérativement être les paramètres deux et suivants, puisque le premier paramètre indique toujours la taille de la zone de mémoire à allouer.</p>
<p>Comme le premier paramètre est calculé par le compilateur, il n&rsquo;y a pas de syntaxe permettant de le passer aux opérateurs new et new[]. En revanche, une syntaxe spéciale est nécessaire pour passer les paramètres supplémentaires. Cette syntaxe est détaillée ci-dessous.</p>
<p>Si l&rsquo;opérateur new est déclaré de la manière suivante dans la classe classe :</p>
<p>static void *operator new(size_t taille, paramètres);</p>
<p>où taille est la taille de la zone de mémoire à allouer et paramètres la liste
des paramètres additionnels, alors on doit l&rsquo;appeler avec la syntaxe
<code>new(paramètres classes);</code></p>
<p>Les paramètres sont donc passés entre parenthèses comme pour une fonction normale. Le nom de la fonction est new, et le nom de la classe suit l&rsquo;expression new comme dans la syntaxe sans paramètres. Cette utilisation de new est appelée new avec placement.</p>
<p>Le placement est souvent utilisé afin de réaliser des réallocations de mémoire d&rsquo;un objet à un autre. Par exemple, si l&rsquo;on doit détruire un objet alloué dynamiquement et en reconstruire immédiatement un autre du même type, les opérations suivantes se déroulent :</p>
<ol>
<li>appel du destructeur de l&rsquo;objet (réalisé par l&rsquo;expression delete) ;</li>
<li>appel de l&rsquo;opérateur delete ;</li>
<li>appel de l&rsquo;opérateur new ;</li>
<li>appel du constructeur du nouvel objet (réalisé par l&rsquo;expression new).</li>
</ol>
<p>Cela n&rsquo;est pas très efficace, puisque la mémoire est restituée pour être allouée de nouveau immédiatement après. Il est beaucoup plus logique de réutiliser la mémoire de l&rsquo;objet à détruire pour le nouvel objet, et de reconstruire ce dernier dans cette mémoire. Cela peut se faire comme suit :</p>
<ol>
<li>appel explicite du destructeur de l&rsquo;objet à détruire ;</li>
<li>appel de new avec comme paramètre supplémentaire le pointeur sur l&rsquo;objet détruit ;</li>
<li>appel du constructeur du deuxième objet (réalisé par l&rsquo;expression new).</li>
</ol>
<p>L&rsquo;appel de new ne fait alors aucune allocation : on gagne ainsi beaucoup de
temps.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span> 
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    A(<span style="color:#66d9ef">void</span>)           <span style="color:#75715e">// Constructeur.
</span><span style="color:#75715e"></span>    {
        <span style="color:#66d9ef">return</span> ;
    }
 
    <span style="color:#f92672">~</span>A(<span style="color:#66d9ef">void</span>)          <span style="color:#75715e">// Destructeur.
</span><span style="color:#75715e"></span>    {
        <span style="color:#66d9ef">return</span> ;
    }
 
    <span style="color:#75715e">// L&#39;opérateur new suivant utilise le placement.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Il reçoit en paramètre le pointeur sur le bloc
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// à utiliser pour la requête d&#39;allocation dynamique
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// de mémoire.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">new</span> (size_t taille, A <span style="color:#f92672">*</span>bloc)
    {
        <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>) bloc;
    }
 
    <span style="color:#75715e">// Opérateur new normal :
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">new</span>(size_t taille)
    {
        <span style="color:#75715e">// Implémentation :
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> malloc(taille);
    }
 
    <span style="color:#75715e">// Opérateur delete normal :
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">delete</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>pBlock)
    {
        free(pBlock);
        <span style="color:#66d9ef">return</span> ;
    }
};
 
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>)
{
    A <span style="color:#f92672">*</span>pA<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> A;      <span style="color:#75715e">// Création d&#39;un objet de classe A.
</span><span style="color:#75715e"></span>                      <span style="color:#75715e">// L&#39;opérateur new global du C++ est utilisé.
</span><span style="color:#75715e"></span>    pA<span style="color:#f92672">-&gt;~</span>A();         <span style="color:#75715e">// Appel explicite du destructeur de A.
</span><span style="color:#75715e"></span>    A <span style="color:#f92672">*</span>pB<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span>(pA) A;  <span style="color:#75715e">// Réutilisation de la mémoire de A.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">delete</span> pB;        <span style="color:#75715e">// Destruction de l&#39;objet.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>Dans cet exemple, la gestion de la mémoire est réalisée par les opérateurs new
et delete normaux. Cependant, la réutilisation de la mémoire allouée se fait
grâce à un opérateur new avec placement, défini pour l&rsquo;occasion. Ce dernier ne
fait strictement rien d&rsquo;autre que de renvoyer le pointeur qu&rsquo;on lui a passé en
paramètre. On notera qu&rsquo;il est nécessaire d&rsquo;appeler explicitement le destructeur
de la classe A avant de réutiliser la mémoire de l&rsquo;objet, car aucune expression
delete ne s&rsquo;en charge avant la réutilisation de la mémoire.</p>
<p>Il est impossible de passer des paramètres à l&rsquo;opérateur delete dans une
expression delete. Cela est dû au fait qu&rsquo;en général on ne connaît pas le
contexte de la destruction d&rsquo;un objet (alors qu&rsquo;à l&rsquo;allocation, on connaît le
contexte de création de l&rsquo;objet). Normalement, il ne peut donc y avoir qu&rsquo;un
seul opérateur delete. Cependant, il existe un cas où l&rsquo;on connaît le contexte
de l&rsquo;appel de l&rsquo;opérateur delete : c&rsquo;est le cas où le constructeur de la classe
lance une exception (voir le Chapitre 9 pour plus de détails à ce sujet). Dans
ce cas, la mémoire allouée par l&rsquo;opérateur new doit être restituée et
l&rsquo;opérateur delete est automatiquement appelé, puisque l&rsquo;objet n&rsquo;a pas pu être
construit. Afin d&rsquo;obtenir un comportement symétrique, il est permis de donner
des paramètres additionnels à l&rsquo;opérateur delete. Lorsqu&rsquo;une exception est
lancée dans le constructeur de l&rsquo;objet alloué, l&rsquo;opérateur delete appelé est
l&rsquo;opérateur dont la liste des paramètres correspond à celle de l&rsquo;opérateur new
qui a été utilisé pour créer l&rsquo;objet. Les paramètres passés à l&rsquo;opérateur delete
prennent alors exactement les mêmes valeurs que celles qui ont été données aux
paramètres de l&rsquo;opérateur new lors de l&rsquo;allocation de la mémoire de l&rsquo;objet.
Ainsi, si l&rsquo;opérateur new a été utilisé sans placement, l&rsquo;opérateur delete sans
placement sera appelé. En revanche, si l&rsquo;opérateur new a été appelé avec des
paramètres, l&rsquo;opérateur delete qui a les mêmes paramètres sera appelé. Si aucun
opérateur delete ne correspond, aucun opérateur delete n&rsquo;est appelé (si
l&rsquo;opérateur new n&rsquo;a pas alloué de mémoire, cela n&rsquo;est pas grave, en revanche, si
de la mémoire a été allouée, elle ne sera pas restituée). Il est donc important
de définir un opérateur delete avec placement pour chaque opérateur new avec
placement défini. L&rsquo;exemple précédent doit donc être réécrit de la manière
suivante :</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span> 
<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">bool</span> bThrow <span style="color:#f92672">=</span> false;
 
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    A(<span style="color:#66d9ef">void</span>)           <span style="color:#75715e">// Constructeur.
</span><span style="color:#75715e"></span>    {
        <span style="color:#75715e">// Le constructeur est susceptible
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// de lancer une exception :
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (bThrow) <span style="color:#66d9ef">throw</span> <span style="color:#ae81ff">2</span>;
        <span style="color:#66d9ef">return</span> ;
    }
 
    <span style="color:#f92672">~</span>A(<span style="color:#66d9ef">void</span>)          <span style="color:#75715e">// Destructeur.
</span><span style="color:#75715e"></span>    {
        <span style="color:#66d9ef">return</span> ;
    }
 
    <span style="color:#75715e">// L&#39;opérateur new suivant utilise le placement.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Il reçoit en paramètre le pointeur sur le bloc
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// à utiliser pour la requête d&#39;allocation dynamique
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// de mémoire.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">new</span> (size_t taille, A <span style="color:#f92672">*</span>bloc)
    {
        <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>) bloc;
    }
 
    <span style="color:#75715e">// L&#39;opérateur delete suivant est utilisé dans les expressions
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// qui utilisent l&#39;opérateur new avec placement ci-dessus,
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// si une exception se produit dans le constructeur.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">delete</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>p, A <span style="color:#f92672">*</span>bloc)
    {
        <span style="color:#75715e">// On ne fait rien, parce que l&#39;opérateur new correspondant
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// n&#39;a pas alloué de mémoire.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> ;
    }
 
    <span style="color:#75715e">// Opérateur new et delete normaux :
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">new</span>(size_t taille)
    {
        <span style="color:#66d9ef">return</span> malloc(taille);
    }
 
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">delete</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>pBlock)
    {
        free(pBlock);
        <span style="color:#66d9ef">return</span> ;
    }
};
 
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>)
{
    A <span style="color:#f92672">*</span>pA<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> A;      <span style="color:#75715e">// Création d&#39;un objet de classe A.
</span><span style="color:#75715e"></span>    pA<span style="color:#f92672">-&gt;~</span>A();         <span style="color:#75715e">// Appel explicite du destructeur de A.
</span><span style="color:#75715e"></span>    bThrow <span style="color:#f92672">=</span> true;    <span style="color:#75715e">// Maintenant, le constructeur de A lance
</span><span style="color:#75715e"></span>                      <span style="color:#75715e">// une exception.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">try</span>
    {
        A <span style="color:#f92672">*</span>pB<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span>(pA) A;  <span style="color:#75715e">// Réutilisation de la mémoire de A.
</span><span style="color:#75715e"></span>                          <span style="color:#75715e">// Si une exception a lieu, l&#39;opérateur
</span><span style="color:#75715e"></span>                          <span style="color:#75715e">// delete(void *, A *) avec placement
</span><span style="color:#75715e"></span>                          <span style="color:#75715e">// est utilisé.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">delete</span> pB;        <span style="color:#75715e">// Destruction de l&#39;objet.
</span><span style="color:#75715e"></span>    }
    <span style="color:#66d9ef">catch</span> (...)
    {
        <span style="color:#75715e">// L&#39;opérateur delete(void *, A *) ne libère pas la mémoire
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// allouée lors du premier new. Il faut donc quand même
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// le faire, mais sans delete, car l&#39;objet pointé par pA
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// est déjà détruit, et celui pointé par pB l&#39;a été par
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// l&#39;opérateur delete(void *, A *) :
</span><span style="color:#75715e"></span>        free(pA);
    }
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>Quelle que soit la syntaxe que vous désirez utiliser, les opérateurs new, new[], delete et delete[] doivent avoir un comportement bien déterminé. En particulier, les opérateurs delete et delete[] doivent pouvoir accepter un pointeur nul en paramètre. Lorsqu&rsquo;un tel pointeur est utilisé dans une expression delete, aucun traitement ne doit être fait.</p>

					</div>
					<div class="post-comments">
						
					</div>
				</div>
			</div>
      <div class="col-md-4">
        <aside class="sidebar"><div class="widget widget-tag">
    <h4 class="widget-title">Mots clefs</h4>
    <ul class="widget-tag-list">
      <li><a href="/tags/c&#43;&#43;">C&#43;&#43;</a></li>
      <li><a href="/tags/compilation">Compilation</a></li>
      <li><a href="/tags/poo">Poo</a></li>
      <li><a href="/tags/programmation-syst%c3%a8me">Programmation système</a></li>
      <li><a href="/tags/quantique">Quantique</a></li>
      <li><a href="/tags/syst%c3%a8me-de-gestion-de-base-de-donn%c3%a9es">Système de gestion de base de données</a></li>
      <li><a href="/tags/tcp-ip">Tcp ip</a></li>
    </ul>
</div>


<div class="widget widget-latest-post">
    <h4 class="widget-title">Derniers cours</h4>
    
    <div class="media">
      <div class="media-body">
        <h4 class="media-heading"><a href="https://Sdelpeuch.github.io/assets/md/cpp/7/">Les templates</a></h4>
        <h5>[C&#43;&#43;]</h5>
        <p>Généralités Nous avons vu précédemment comment …</p>
      </div>
    </div>
    
    <div class="media">
      <div class="media-body">
        <h4 class="media-heading"><a href="https://Sdelpeuch.github.io/assets/md/cpp/6/">Les espaces de nommage</a></h4>
        <h5>[C&#43;&#43;]</h5>
        <p>Les espaces de nommage sont des zones de …</p>
      </div>
    </div>
    
    <div class="media">
      <div class="media-body">
        <h4 class="media-heading"><a href="https://Sdelpeuch.github.io/assets/md/cpp/5/">Les exceptions en C&#43;&#43;</a></h4>
        <h5>[C&#43;&#43;]</h5>
        <p>Une exception est l&rsquo;interruption de …</p>
      </div>
    </div>
    
    <div class="media">
      <div class="media-body">
        <h4 class="media-heading"><a href="https://Sdelpeuch.github.io/assets/md/prog_sys/14/">Les threads POSIX</a></h4>
        <h5>[Programmation Système]</h5>
        <p>La programmation par thread (activité) est …</p>
      </div>
    </div>
    
    <div class="media">
      <div class="media-body">
        <h4 class="media-heading"><a href="https://Sdelpeuch.github.io/assets/md/prog_sys/13/">Multiplexer des entrées-sorties</a></h4>
        <h5>[Programmation Système]</h5>
        <p>Dans ce chapitre, nous voulons présenter le …</p>
      </div>
    </div>
    
    <div class="media">
      <div class="media-body">
        <h4 class="media-heading"><a href="https://Sdelpeuch.github.io/assets/md/prog_sys/12/">Algorithmes Distribués &amp; Interblocages</a></h4>
        <h5>[Programmation Système]</h5>
        <p>Ce chapitre introduit les problèmes liés à la …</p>
      </div>
    </div>
    
  </div>
</aside>


      </div>
		</div>
	</div>
</section>

<footer class="footer">
	<div class="container">
		<div class="row">
			<div class="col-md-12">
				<div class="footer-manu">
					<ul>
            
            <li><a href="https://Sdelpeuch.github.io/about">Semestre 7</a></li>
            
            <li><a href="https://Sdelpeuch.github.io/contact">Semestre 6</a></li>
            
            <li><a href="https://Sdelpeuch.github.io/project">Semestre 5</a></li>
            
            <li><a href="https://Sdelpeuch.github.io/cpbx">CPBx</a></li>
            
					</ul>
				</div>
				<p class="copyright">Copyright © 2020 <a href="https://themefisher.com">Themefisher</a> All Rights Reserved</p>
			</div>
		</div>
	</div>
</footer>



<script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCcABaamniA6OL5YvYSpB3pFMNrXwXnLwU&amp;libraries=places"></script>




<script src="https://Sdelpeuch.github.io/plugins/jQuery/jquery.min.js"></script>

<script src="https://Sdelpeuch.github.io/plugins/bootstrap/bootstrap.min.js"></script>

<script src="https://Sdelpeuch.github.io/plugins/slick/slick.min.js"></script>

<script src="https://Sdelpeuch.github.io/plugins/magnific-popup/jquery.magnific-popup.min.js"></script>

<script src="https://Sdelpeuch.github.io/plugins/shuffle/shuffle.min.js"></script>

<script src="https://Sdelpeuch.github.io/plugins/google-map/gmap.js"></script>




<script src="https://Sdelpeuch.github.io/js/script.min.js"></script>







<script src="https://cdnjs.cloudflare.com/ajax/libs/js-cookie/2.2.1/js.cookie.min.js"></script>
<div id="js-cookie-box" class="cookie-box cookie-box-hide">
	This site uses cookies. By continuing to use this website, you agree to their use. <span id="js-cookie-button" class="btn btn-main btn-solid-border">I Accept</span>
</div>
<script>
	(function ($) {
		const cookieBox = document.getElementById('js-cookie-box');
		const cookieButton = document.getElementById('js-cookie-button');
		if (!Cookies.get('cookie-box')) {
			cookieBox.classList.remove('cookie-box-hide');
			cookieButton.onclick = function () {
				Cookies.set('cookie-box', true, {
					expires:  2 
				});
				cookieBox.classList.add('cookie-box-hide');
			};
		}
	})(jQuery);
</script>


<style>
.cookie-box {
  position: fixed;
  left: 0;
  right: 0;
  bottom: 0;
  text-align: center;
  z-index: 9999;
  padding: 1rem 2rem;
  background: rgb(71, 71, 71);
  transition: all .75s cubic-bezier(.19, 1, .22, 1);
  color: #fdfdfd;
}

.cookie-box-hide {
  display: none;
}
</style>
</body>

</html>