---
layout: page
hide: true
title: Opérateurs
---
<script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<style>
html {
 zoom: 0.80;
}
</style>

## Définition 

Un opérateur est une notation raccourcie permettant de représenter une opération
fréquemment utilisée, par exemple : `a+b*c;`. On ajoute à `a` le résultat de la
multiplication de `b` par `c`. Si `a` est un pointeur, le sens change : on
ajoute à `a`, `b*c*sizeof(T)` octets (si `T` est le type pointé par `a`). Dans
le cas où `a` n'est pas un type primitif, cette notation est invalide sauf si
l'on fournit la fonction permettant d'effectuer cette opération.

## Condition 

Pour pouvoir écrire un opérateur, au moins une des opérandes de cet opérateur
doit correspondre à un type utilisateur (pas primitif). Par exemple, on ne peut
pas modifier l'addition sur les entiers. 

Les opérateurs ne sont pas considérés comme commutatifs par le compilateur.
C'est à dire que si l'on a écrit un opérateur permettant de faire l'addition
d'un A avec un B, `B() + A();` ne sera pas résolu par cet opérateur. 

La précédente des opérateurs ne peut être modifiée.

## Syntaxe

Un opérateur $$\alpha$$ s'écrira sous le nom d'une fonction ou méthode **non
statique** de nom `operator` $$\alpha$$. Le type de retour de cette fonction est
libre. 

C'est le premier paramètre qui est prioritaire pour la résolution. Dans le cas
d'une méthode, le premier paramètre (correspondant à `this` dans la méthode)
sera une référence du type de la classe. 
```cpp
class A{
    public :
    int operator+(int i);
};
```

Il faut voir cette méthode comme
définissant l'opération + entre une instance de A **non constante** et un entier

## Conception 

Lorsque l'on écrit un nouvel opérateur, il faut faire attention à ce que
l'introduction de ce "raccourci" n'apporte pas d'ambiguïté : le but de
l'opérateur est de simplifier, pas de compliquer. En cas de doute, préférer
toujours l'utilisation de fonctions ou méthodes classiques. Un exemple de
mauvaise utilisation des opérateurs : la bibliothèque standard. 

La bibliothèque standard `iostream` fournit un modèle orienté-objet des entrées
sorties, elle se décompose en : 
+ `ios` : bases pour les entrées / sorties 
+ `istream` : entrées
+ `ostream` : sorties
+ `streambuf` : flux bufferisés
+ `iostream` : entrées et sorties 
+ `fstream` : fichiers 
+ `sstream` : chaines de caractères

L'ensemble des classes font parties de l'espace de nom `std`. Outre un ensemble
de fonctionnalités permettant la gestion des flux, il a été ajouté un support
pour la lecture et l'écriture basé sur les opérateurs.

Comment adapter votre classe pour pouvoir utiliser l'affichage de la
bibliothèque standard : 
```cpp
class Entier{ int v;};
int main(){
    Entier e;
    std::cerr<<"debug"<<e;
}
```
Erreur à la compilation ! Nous devons écrire l'opérateur `<<` pour la classe
`std::ostream` et `Entier` : 

```cpp

class Entier{
    int v;
    public :
    friend std::ostream &operator <<(std :: ostream &stream, const Entier &e);
};

std::ostream &operator<<(std::ostream &stream, Entier e){
    stream<<e.v;
    return stream;
}
```

## Opérateur d'affectation

L'opérateur d'affectation correspond au `=` et doit nécessairement être écrit
sous la forme d'un membre de classe. Le compilateur fournit toujours un
opérateur d'affectation permettant de copier une instance dans une instance de
même type. L'opérateur d'affectation fournit est de la forme 
```cpp
X &X :: operator = (const X&); //1
X &X :: operator = (X&); //2
```

Dans les deux cas, la copie est effectuée attribut par attribut dans l'ordre de
leur déclaration. La forme 1 est utilisée si chaque attribut possède un
opérateur d'affectation en forme 1. Si l'on déclare explicitement un opérateur
d'affectation en forme 1 ou 2 alors le compilateur n'ajoute plus l'opérateur. Si
la classe possède un attribut constant ou de type référence, le compilateur ne
peut pas définir l'opérateur d'affectation.

## Opérateur : foncteur

L'opérateur de fonction est le seul opérateur d'instance (ie à part `new` et
`delete`) qui peut prendre un nombre variable d'arguments. Pour les autres, le
nombre d'arguments est fixé par l'arité de l'opérateur. Une classe qui
implémente cet opérateur est appelée foncteur car l'on peut utiliser une
instance comme fonction : 
```cpp
class Greater{
    public: 
        bool operator()(int a, int b){return a>b;}
        bool operator()(double a, double b){return a>b;}
        bool operator()(const char *a, const char *b){return stcmp(a,b)>0;}

};
...
Greater greater;
if(greater(1,0)){...}
if(greater("aba","abb")){...}
```

On aurait aussi bien pu écrire plusieurs fonctions greater en utilisant la
surcharge. Un autre exemple plus utile (et complexe) est l'implémentation d'une
fonction de hachage paramétrable (attributs).

## Opérateur : de conversion

Il est possible d'écrire des opérateurs prenant en charge la conversion d'une
instance vers un autre type 

```cpp
class Entier{
    int _value;
    public : 
        operator int() const{
            return _value;
        }
};
```

Le prototype de l'opérateur de conversion est `operator type() const`, ne
possède pas de type de retour (puisque c'est `type`) et ne prend pas d'argument.
L'opérateur de conversion s'écrit obligatoirement sous la forme d'une fonction
membre. L'opérateur de conversion peut être appelé explicitement avec un cast ou
bien implicitement 
```cpp
void f(int);
...
Entier e;
int i=e; //conversion implicite
(int )e; //conversion explicite
f(e); // conversion implicite
```

Les opérateurs de conversions sont pris en compte par l'algorithme de
résolution. Une utilisation intéressante de l'opérateur de conversion est la
conversion en 
```cpp
std::string:
#include <string>
class Entier{
    public : 
        operator int() const{return _value;}
        operateur std::string()const{
            std::stringstream s;
            s<<_value;
            return s.str();
        }
};
...
Entier e;
cout<<(std::string)e;
```

Cette approche est plus logique (que l'implémentation de `<<`) et permet plus de
possibilités 

## Opérateurs : autres 

L'opérateur `[]` est souvent utilisé. Il prend un seul argument et doit
obligatoirement être écrit comme fonction membre. L'opérateur `new` est utilisé
pour faire du placement d'objet en mémoire. Il permet d'écrire ces propres
allocateurs ou encore de faire du "debug-age". Le nombre d'argument est variable
mais le premier est obligatoirement de type `size_t`, le type de retour est
obligatoirement `void*`. 

## Opérateurs : new 

Il existe 2 versions de l'opérateur `new` : 
```cpp
void *operator new(size_t) throw(bad_alloc);
void *operator new(size_t, const nothrow_t &) throw();
```

2 versions de l'opérateur `new[]`
```cpp
void *operator new[](size_t) throw(bad_alloc);
void *operator new[](size_t, const nothrow_t &) throw();
```

La première version lève une exception dans le cas où l'allocation demandée pose
problème (plus assez de mémoire). 

La deuxième garantie de ne pas lever d'exception et renvoie 0 en cas de
problème. 

```cpp
int *i=new int;
int *j=new (notthrow) int;
```

Ces versions de l'opérateur new sont redefinissable : 
```cpp
void *operator new(size_t s){
    printf("allocation de %d octets");
    return new(s,nothrow); //version sans exception
}
...
int *i=new int;
```

Ici, on utilise la version sans exception de l'opérateur new fourni par la
bibliothèque standard pour effectuer l'allocation mémoire. 
Il faut noter que toutes les allocations dynamiques passeront par notre
fonction.
Il existe aussi une version de placement de l'opérateur `new`
```cpp
void *operator new(size_t, void*) throw();
void *operator new[](size_t, void*) throw();
```

Ces versions, dites de placement, ne sont pas redéfinissables et retourne
l'adresse passée en argument. Elles permettent de créer une instance à uun
emplacement mémoire précis
```cpp
char data[1000];
int *i=new(data) int;
```

On peut aussi créer son propre allocateur, pour cela il faut écrire une fonction
`void *operator new(size_t, <args>)`. Cette fonction ne peut pas faire partie
d'un espace de nom
