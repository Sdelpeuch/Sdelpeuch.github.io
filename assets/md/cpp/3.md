---
layout: page
hide: true
title: Opérateurs
---
<script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<style>
html {
 zoom: 0.80;
}
</style>

## Définition 

Un opérateur est une notation raccourcie permettant de représenter une opération
fréquemment utilisée, par exemple : `a+b*c;`. On ajoute à `a` le résultat de la
multiplication de `b` par `c`. Si `a` est un pointeur, le sens change : on
ajoute à `a`, `b*c*sizeof(T)` octets (si `T` est le type pointé par `a`). Dans
le cas où `a` n'est pas un type primitif, cette notation est invalide sauf si
l'on fournit la fonction permettant d'effectuer cette opération.

## Condition 

Pour pouvoir écrire un opérateur, au moins une des opérandes de cet opérateur
doit correspondre à un type utilisateur (pas primitif). Par exemple, on ne peut
pas modifier l'addition sur les entiers. 

Les opérateurs ne sont pas considérés comme commutatifs par le compilateur.
C'est à dire que si l'on a écrit un opérateur permettant de faire l'addition
d'un A avec un B, `B() + A();` ne sera pas résolu par cet opérateur. 

La précédente des opérateurs ne peut être modifiée.

## Syntaxe

Un opérateur $$\alpha$$ s'écrira sous le nom d'une fonction ou méthode **non
statique** de nom `operator` $$\alpha$$. Le type de retour de cette fonction est
libre. 

C'est le premier paramètre qui est prioritaire pour la résolution. Dans le cas
d'une méthode, le premier paramètre (correspondant à `this` dans la méthode)
sera une référence du type de la classe. 
```cpp
class A{
    public :
    int operator+(int i);
};
```

Il faut voir cette méthode comme
définissant l'opération + entre une instance de A **non constante** et un entier

## Conception 

Lorsque l'on écrit un nouvel opérateur, il faut faire attention à ce que
l'introduction de ce "raccourci" n'apporte pas d'ambiguïté : le but de
l'opérateur est de simplifier, pas de compliquer. En cas de doute, préférer
toujours l'utilisation de fonctions ou méthodes classiques. Un exemple de
mauvaise utilisation des opérateurs : la bibliothèque standard. 

La bibliothèque standard `iostream` fournit un modèle orienté-objet des entrées
sorties, elle se décompose en : 
+ `ios` : bases pour les entrées / sorties 
+ `istream` : entrées
+ `ostream` : sorties
+ `streambuf` : flux bufferisés
+ `iostream` : entrées et sorties 
+ `fstream` : fichiers 
+ `sstream` : chaines de caractères

L'ensemble des classes font parties de l'espace de nom `std`. Outre un ensemble
de fonctionnalités permettant la gestion des flux, il a été ajouté un support
pour la lecture et l'écriture basé sur les opérateurs.

Comment adapter votre classe pour pouvoir utiliser l'affichage de la
bibliothèque standard : 
```cpp
class Entier{ int v;};
int main(){
    Entier e;
    std::cerr<<"debug"<<e;
}
```
Erreur à la compilation ! Nous devons écrire l'opérateur `<<` pour la classe
`std::ostream` et `Entier` : 

```cpp

class Entier{
    int v;
    public :
    friend std::ostream &operator <<(std :: ostream &stream, const Entier &e);
};

std::ostream &operator<<(std::ostream &stream, Entier e){
    stream<<e.v;
    return stream;
}
```

## Opérateur d'affectation

L'opérateur d'affectation correspond au `=` et doit nécessairement être écrit
sous la forme d'un membre de classe. Le compilateur fournit toujours un
opérateur d'affectation permettant de copier une instance dans une instance de
même type. L'opérateur d'affectation fournit est de la forme 
```cpp
X &X :: operator = (const X&); //1
X &X :: operator = (X&); //2
```

Dans les deux cas, la copie est effectuée attribut par attribut dans l'ordre de
leur déclaration. La forme 1 est utilisée si chaque attribut possède un
opérateur d'affectation en forme 1. Si l'on déclare explicitement un opérateur
d'affectation en forme 1 ou 2 alors le compilateur n'ajoute plus l'opérateur. Si
la classe possède un attribut constant ou de type référence, le compilateur ne
peut pas définir l'opérateur d'affectation.
