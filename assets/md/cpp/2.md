---
layout: page
hide: true
title: Classes
---
<script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<style>
html {
 zoom: 0.80;
}
</style>

## Définition et déclaration

Une classe consiste en un regroupement de méthodes et d'attributs 
```
class NomClasse{
attributes
...
methodes
...
};
```

L'ordre des déclarations ne compte pas. La classe est une description des
données internes et comportements qu'aura une instance générée par cette classe.

L'**instanciation** (ou réification), c'est à dire la création d'un objet
instance (ressource) à partir de l'objet classe (description / générateur) peut
se faire de façon dynamique
```
A *a=new A();
```

ou automatique 
```
A a;
```

Dans les deux cas, une ressource (adresse mémoire) est associée à l'instance.
Dans l'allocation dynamique, cette ressource est située dans le tas, dans le cas
automatique elle est située dans la pile.

## Visibilité, friend, struct
On contrôle l'accès au méthodes et attributs pour une sous-classe ou un objet
extérieur avec `public, protected, private`

|           | la classe | sous-classe | extérieur |
| public    | oui       | oui         | oui       |
| protected | oui       | oui         | non       |
| private   | oui       | non         | non       |

La visibilité par défaut dans une classe est private. On modifie la visibilité
de la façon suivante

```cpp
class NomClasse{
//attributs et méthodes privés
public:
//attributs et méthodes publiques
protected:
//attributs et méthodes protégés
}
```

On peut à tout moment changer la visibilité, celle-ci sera appliquée à toutes
les déclarations suivantes jusqu'au prochaine changement de visibilité. 

### Les structures

Les structures se déclarent comme en C. En C++, les structures sont des classes
dont la visibilité par défaut est `public`. Par conséquent, elles peuvent
contenir des attributs et des méthodes. Deux noms de type sont associés à la
structure : struct Nom et Nom. 

L'instanciation des structures se fait comme pour les classes 

allocation dynamique
```cpp
struct A{...};
A *a = new A();
A *a = new struct A();
struct A *a = new struct A();
```

allocation automatique
```cpp
struct A{...};
A a;
struct A a;
```

### Friend

Dans une classe `A`, le mot clé `friend` permet de donner à une fonction ou une
autre classe les mêmes droits qu'une méthode de `A`. Une fonction `f` amie d'une
classe `A` pourra accéder aux attributs privés de `A` ainsi qu'aux attributs
privés de `A` ainsi qu'aux attributs protected d'une des classes parents de `A`.

La déclaration se fait dans la classe en indiquant soit le prototype de la
fonction amié soit le nom de la classe amie 

Classe amie 
```cpp
class NomClasse{
...; friend class NomClasseAmie; ...
};
```

Fonction amie
```cpp
class NomClasse{
...; friend void fonctionAmie(int,char, NomClasse); ...
};
```

la visibilité courante n'importe pas pour déclarer une classe ou fonction amie.

## Attributs et méthodes
Une classe est un regroupement d'attributs, propriétés interne qu'aura une
instance de la classe, et de méthodes, comportements qu'aura une instance. Ces
attributs sont déclarés à l'intérieur de la classe. L'implémentation des
méthodes peut se faire au moment de la déclaration ou à l'extérieur de la
classe. On l'écrira dans la classe pour 
+ les classes template
+ les classes à usage locale au fichier
+ l'inlining

Sinon on écrit un fichier entête `NomClasse.hpp` et un fichier source
`NomClasse.cpp`

### Accès aux attributs

L'accès aux champs d'une classe se fait à l'aide de `.` ou `->` selon que l'on
dispose d'une instance de classe ou d'un pointeur sur une instance de classe.
Tout membre de classe a pour nom `NomClasse::membre`. Lorsqu'il n'y a pas
d'ambiguïté, `NomClasse::` peut être omis.

Cas automatique
```cpp
ClasseA a;
a.i = 1; //i est un attribut public de ClasseA
a.ClasseA::i=1; //idem
a.methode(); //appel de méthode 
a.ClasseA::methode(); //idem
```

Dans ce cas l'instance se trouve dans la **pile**. 

Cas dynamique 
```cpp
ClasseA *a = new ClasseA();
a->i = 1; 
a->ClasseA::i = 1;
a->methode();
a->ClasseA::methode();
```

Dans ce cas l'instance est allouée dynamique dans le tas.

## This

Le mot clé `this` permet, lors d'un appel de méthode, de faire référence à
l'instance source (site d'appel). Le type de la variable `this` est `NomDeClasse
const * ` : c'est un pointeur. 

```cpp
class A{
    int attributPrive;
    public:
    voir setAttribut(int valeur){
        this->attributPrive=valeur;
    }
}
```

Lorsqu'il n'y a pas de variable locale de même nom que l'attribut, on peut
omettre this. 

### Opérateur de portée

L'opérateur de portée `::` peut être utilisé pour indiquer précisément la
variable que l'on souhaite manipuler.

```cpp
int lunatique;
class A{
    char lunatique;
    public :
        void printAllVariable(double lunatique){
            lunatique;
            A::lunatique; // fait référence à la variable locale
            this->A::lunatique; // fait référence à l'attribut d'instance 
            this->lunatique; // fait référence à l'attribut d'instance
            ::lunatique; // fait référence à la variable globale
        }
}
```

## Espace de nom

Les espaces de nom permettent de regrouper un ensemble d'éléments (classes,
variables, globales, fonctions,...). Les espaces de nom sont utilisés pour
structurer le code et pour éviter les problèmes de collisions. Pour déclarer un
espace de nom on utilise le mot clé `namespace`
```cpp
namespace Nom{
    class A{
        ...
    };
    int i;
    int fonction();
} // fin de l'espace de nom
```

Lors de l'écriture du code des fonctions ou des méthodes des classes dans le
fichier .cpp on peut soit ré-ouvrir l'espace de nom, soit indiquer explicitement
le nom de l'objet avec l'opérateur de portée.
```cpp
namespace tec{
    class A{
        public:
            void m();
    };
};
```

Lors de l'écriture du code des fonctions ou des méthodes des classes dans le
fichier .cpp on peut soit ré-ouvrir l'espace de nom, soit indiquer explicitement
le nom de l'objet avec l'opérateur de portée.

### Espace de noms : using

Le mot clé `using` permet de rendre accessible tout ou partie d'un espace de nom
dans une fonction, un espace nom ou tout le code 

```cpp
namespace spatial{
    class Navette{};
}

namespace missions{
    spatial::Navette n;
}

spatial::Navette n;
void starWars(){
    spatial::Navette n;
}
```

Le `using` crée des synonymes locaux entre les espaces de nom :

example.hpp
```cpp
namespace math{
    const double pi=3.14;
}
namespace cercle{
    using math::pi;
    double surf(double);
}
```

exemple.cpp
```cpp
#include "exemple.hpp"
double cercle::surf(double r){
    return pi*r*r;
}
```

Permet de remplacer facilement une référence externe par une autre. Permet aussi
l'introduction de modularité sans modification profonde du code.

## Constructeur

Un constructeur est une méthode de classe qui est appelée après la reservation
des ressources nécessaires à la création d'une instance de la classe et qui a
pour objectif d'initialiser les attributs de cette instance.

### Définition

Une constructeur est une méthode de classe qui est appelée après la réservation
des ressources nécessaires à la créations d'une instance de la classe et qui a
pour objectif d'initialiser les attributs de cette instance. En C++, le
constructeur est une méthode sans valeur de retour de même nom que la classe. On
appelle constructeur par défaut le constructeur ne prenant aucun argument. Dans
le cas où la classe ne comporte aucun constructeur, le compilateur ajoute un
constructeur par défaut. Celui-ci n'est plus présent à partir du moment où l'on
a écrit au moins un constructeur.

### Par recopie

Le constructeur par recopie est le constructeur qui permet d'instancier une
classe à partir d'une autre instance de cette classe. Ce constructeur est
utilisé entre autre lors de la transmission de paramètres à une fonction et lors
d'une valeur de retour de fonction 

```cpp
A f(A p){return p;}
...
A a;
f(a)
```

+ La variable `p`, locale à la fonction `f`, est allouée automatiquement et
  instanciée avec le constructeur par recopie à partir de l'instance `a`.
+ La valeur de retour de `f` est instanciée par recopie de la valeur locale.

L'idée est donc d'avoir un constructeur dans la classe `A` qui prend une
instance de type `A` en argument

```cpp
class A{
    public:
        A(A a);
};
```

Le problème est que pour instancier la variable locale au constructeur il nous
faut le constructeur par recopie. La solution repose sur l'utilisation des
références 

```cpp
class A{
    public:
        A(const A&);
        A(A &);
};
```

#### Références. 

Une référence peut être vue comme un "alias" sur une instance, une référence
doit obligatoirement être initialisée au moment de sa création et ne peut
référencer une autre instance par la suite. 

```cpp
int i:
int &r=i;
```

Après l'initialisation :
+ les variables `i` et `r` représentent la même donnée
+ l'adresse de `r` est égale à l'adresse de `i`

Contrairement à un pointeur, une référence "pointe" toujours sur une instance. 

```cpp
void swap(int &i, int &j){
    int k=i;
    i=j;
    j=k;
}

int a=3, b=5;
swap(a,b);
int t[5];
swap(t[1],t[2]);
```

#### Const. 

Le mot clé `const` sert à indiquer qu'une donnée ne peut être modifiée. Une
variable déclaré `const` doit être initialisée lors de sa déclaration. Lorsque
l'on dispose d'une référence constante sur une instance de classe, comment
garantir que l'appel à une méthode de cette instance ne va pas modifier
l'instance ?

```cpp
class A{
    int i;
    public: 
        int get(){return i;}
        void set(int i){
            this->i=i;
        }
};

void f(const A &a){
    a.get();
    a.set(0);
}

A b;
f(b);
```

La référence est constante (l'instance ne doit pas être modifiée) mais l'appel
de méthode modifie l'objet ! On distingue deux types de méthodes : celles qui
sont susceptibles de modifier l'objet et celles qui ne modifient pas l'objet. 

Une méthode de classe peut être typée `const`. Cela indique que dans cette
méthode le type de `this` est `const NomClasse const *`. L'ensemble des
attributs de la classe deviennent alors constants eux aussi. Lorsque l'on
dispose d'une variable constante sur une instance, seules les méthodes indiquées
comme constantes peuvent être appelées sur cette instance. Une méthode `const`
peut appeler sur tout type de variable tandis qu'une méthode non const ne peut
être appelée que sur une variable non constante. 

Lors de l'écriture d'une méthode, on ne doit pas se demander si la méthode doit
être const mais plutôt si on a besoin qu'elle ne soit pas const. 

Les arguments de fonctions (non primitifs) seront des références constantes sauf
si l'on veut modifier l'argument. 

Il est possible de surcharger une méthode en utilisant le `const`

```cpp
class A{
    public:
        void m(){
            printf("Le site d'appel n'est pas constant");
        }
        void m() const{
            printf("Le site d'appel est constant")
        }
};

A a;
const A &b;
A const *p;
a.m();
b.m();
p->m();
```

Le `const` fait partie de la signature de la méthode, il doit être présent dans
le `.cpp` et le `.hpp`.

### Construction 

## Destructeur 

## Static

## Exemple
