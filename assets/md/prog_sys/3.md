---
layout: page
hide: true
title: Processus et gestion mémoire
---
<script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<style>
html {
 zoom: 0.80;
}
</style>

## Abstraction pour le processus et la mémoire 

Le **Processus** est un programme qui s'execute ainsi que son contexte (mémoire,
état des descripteurs de fichiers)

Dans les systèmes d'exploitation : 
+ Support pour de multiples processus 
+ Chaque processus a un espace d'adressage privé ce qui garenti le cloisonnement
  entre processus (sécurité et protection), cela permet d'avoir une abstraction
  de la mémoire et surtout cela cache le noyau et les autres processus.
  
![virtuel](/assets/images/prog_sys/6.png){:class="image about center"}

+ Stack : pile où sont stockées les variables locales 
+ Heap (tas) : allocation dynamique, par malloc
+ Data : zone de données globales ou statiques
+ Texte : zone de code, des instructions du programme

## Gestion mémoire par l'OS

### Lien entre mémoire virtuelle et mémoire réelle 

La traduction de la mémoire virtuelle en mémoire réelle est réalisée par le CPU
(MMU/TLB) via un mécanisme de pages. La mémoire est gérée par blocs de 2ko de
mémoire ce sont les **pages**. Chaque page virtuelle correspondà une page
réelle. 

La traduction s'appuie sur un **mapping** des pages (traduction par
dictionnaire). L'adresse virtuelle est composée de différents champs permettant
de construire l'adresse réelle.

![lien](/assets/images/prog_sys/7.png){:class="image about center"}

### Allocation mémoire

Un ensemble de pages physiques sont allouée à un processus (pour les différentes
zones). L'allocation est une allocation paresseuse 
+ L'allocation de la page est réellement faite que lorsqu'elle est réellement
  accédée
+ Permet une gestion plus économique de la mémoire (plutôt qu'une allocation
  gloutonne)
+ Rôle du swap : si plus de pages physiques, stocke sur disque les pages de
  processus en attente
  
## Interface de programmation pour la gestion mémoire

```c
int brk(void *end_segment);
int skrb(intptr_t displacement);
```

Définit l'adresse virtuelle de la fin du tas 
+ Soit directement avec brk
+ Soit avec un déplacement avec sbrk 

Ces fonctions ne sont pas à utiliser directement, utiliser `malloc` plutôt

```c
void *malloc(size_t size);
void *calloc(size_t count, size_t size);
void *realloc(void *p, size_t size);
```

Cela retourne un pointeur sur une nouvelle zone libre de size octets sur le cas,
NULL si erreur. Beaucoup d'OS font de l'allocation paresseuse. L'OS peut être
amené à terminer certains processus pour libérer de la place.

### Libérer une zonne mémoire allouée sur le tas 

```c
void free(void *ptr)
```

Libère une zone allouée avec `malloc`. Le comportement est indéfini si déjà
libéré ou si pas alloué avec `malloc`. Si `ptr` est NULL, aucune opération n'est effectuée
